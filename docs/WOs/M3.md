Milestone spec you asked for‚Äîwired to v1.5 + Patch v1.6 and our WOs 05/06/07. It keeps everything **pure CS + receipts-first**, no heuristics, no LFP yet.

# Milestone M3 ‚Äî ‚ÄúWitness path‚Äù

**Prereqs:** WO-05 (components), WO-06 (witness_learn), WO-07 (witness_emit) are done and audited.
**New in runner:** enable witness emission and a minimal selector.

---

## Runner contract (src/arcbit/runner.py) ‚Äî M3 delta

```python
def solve(task_json) -> (Y_out, receipts_bundle):
    # M0: color_universe, pack‚Üîunpack, frames, apply_pose_anchor equiv  (unchanged)
    # M1: working_canvas (R_out, C_out) via WO-04a (unchanged)

    # M3: Witness path
    # 1) Evidence for each training input X_i
    comps_i = components(planes_of_Xi, H_i, W_i, colors_order)    # WO-05

    # 2) Learn per-training witness (rigid pieces + œÉ)
    witness_results = [ learn_witness(X_i, Y_i, frames_i) for each training ]  # WO-06

    # 3) Emit global witness (A_wit, S_wit) on (R_out, C_out)
    A_wit, S_wit = emit_witness(X_star, witness_results, frames_all, colors_order, R_out, C_out)  # WO-07

    # 4) (Optional) Unanimity layer OFF at M3: S_uni = 0, A_uni = all-ones; record in receipts as "unanimity_evaluated": false

    # 5) Minimal selector (no LFP yet):
    #    For each pixel p: if S_wit[p]==1 ‚Üí pick min{ c | bit c set in A_wit[c][p] }.
    #                      elif S_uni[p]==1 ‚Üí pick that singleton color.
    #                      else ‚Üí pick bottom 0.
    Y_out = select_witness_first(A_wit, S_wit, A_uni_all_ones, S_uni_zeros, colors_order)

    # 6) Seal receipts (witness_* sections + selection summary) and return.
    return Y_out, receipts_bundle
```

**Notes**

* No domain propagation (no WO-11 yet): the selector treats (D^*=\mathbf{1}) (all colors) everywhere.
* If you‚Äôve already implemented WO-08 (Unanimity), you may pass its ((A_{uni},S_{uni})); otherwise set `S_uni = 0`, `A_uni = all-ones` and log that unanimity was not evaluated.

---

## Minimal selector (frozen, no LFP)

For each pixel (p) on the working canvas:

1. **Witness bucket** (scope-gated):
   `cand = { c ‚àà ùíû : bit A_wit[c][p] == 1 }` if `S_wit[p]==1`, else `‚àÖ`.
   If `cand ‚â† ‚àÖ` pick **min color** in `cand`. (Colors are ascending ints; 0 is allowed but usually not present inside witness scope.)

2. **Unanimity bucket** (M3 default OFF):
   If `S_uni[p]==1`, `cand = { c : A_uni[c][p]==1 }` must be a singleton; pick that `c`.

3. **Bottom**: otherwise pick **0**.

**Containment check:** with (D^*=\mathbf{1}), any picked `c` trivially satisfies `in D*`. Still log `containment_verified:true`.

**Idempotence check:** repaint once and hash; expect identical `Y_out` (log `repaint_hash`).

---

## Receipts (first-class; additive; stable)

Add two sections (names frozen):

1. **`witness_learn` (per training, from WO-06)**

   * `trials` (or at least first-OK per source comp + reject counts),
   * `pieces` (schema fields only),
   * `sigma` (`bijection_ok`, `map`, touched_in/out),
   * `overlap` (`conflict`, counts),
   * `silent` (bool).

2. **`witness_emit` (from WO-07)**

   * `inputs`: `{ "R_out":‚Ä¶, "C_out":‚Ä¶, "num_trainings":‚Ä¶, "num_pieces_total":‚Ä¶ }`
   * `scopes`: `{ "per_training_scope_bits":[‚Ä¶], "scope_bits":‚Ä¶ }`
   * `admits`: `{ "A_wit_hash": "<blake3hex>" }`
   * `unanimity_evaluated`: `false` (at M3) or include its own section later
   * `section_hash`

3. **`selection` (new, M3)**

   * `precedence`: `["witness","unanimity","bottom"]`
   * `counts`: `{ "witness": Nw, "unanimity": Nu, "bottom": Nb }`
   * `containment_verified`: `true`
   * `repaint_hash`: `<blake3hex>`
   * `section_hash`

> Keep all M0/M1/M1‚Äô sections unchanged. No LCM fields anywhere.

---

## Invariants and failure behavior

* **No minted bits**: Within witness scope we only allow colors where a forward-mapped test bit exists; elsewhere admission remains all-ones and scope=0.
* **Silent training**: contributes no scope and acts as admit-all in intersection (already normalized in WO-07).
* **Determinism**: D4 orders, frame composition, bbox‚Üípose‚Üíshift order, color ordering, and selection precedence are all frozen; double-run hashes equal.
* **Clipping**: All shifts/boxes are clipped to ([0..R_{out})√ó[0..C_{out})); zero-fill only.
* **No new hard failures**: Absent code bugs, every task ‚Äúpasses through‚Äù (you always return some `Y_out` and receipts). There‚Äôs no `SIZE_UNDETERMINED` at this stage; that was M1/04a only.

---

## What to wire in runner (no stubs)

* New flags (optional, add-only):

  * `--with-witness` (default **on** at M3),
  * `--with-unanimity` (default **off** at M3; will be used at M4/M5),
  * `--dry-run-selection` (optional dev flag: run selection but also dump counts; receipt already covers this).

* Ensure you pass `R_out,C_out` (from WO-04a) and `colors_order` (from M0) to `emit_witness` and to the selector.

---

## Real-ARC reviewer check (1‚Äì2 lines)

* Pick ~5 simple rigid copy/flip tasks (where WO-06 finds pieces and œÉ is bijection). Verify `selection.counts.witness == R_out*C_out` (or near that if scope < full), `sigma.bijection_ok=true`, `overlap.conflict=false`, and `unanimity_evaluated=false`.

---

## Pitfalls to avoid (from prior audits)

* **Wrong D4 swap set**: only `("R90","R270","FXR90","FXR270")` swap H/W; **not** `FXR180`.
* **Using global masks with bbox dims**: Always crop to bbox when you compute `(H_src,W_src)` or pass local dims to `pose_plane`.
* **Leaking internals in receipts**: never serialize `_mask_*` fields; only schema fields.
* **Not normalizing admit-all**: `S_i` must clear bits where all colors remain admitted.

---

## Dev checklist (implementer)

* Wire the new sections and flags; keep all prior sections verbatim.
* Ensure `emit_witness` sees `X_star` in (\Pi^{in}**) and emits on ((R*{out}, C_{out})).
* Implement `select_witness_first` exactly as above; verify `repaint_hash` stability.
* Add an integration test script that tallies `selection.counts` per task so you can spot regressions quickly.

This gets the **witness path** online cleanly. From here, M4 will add the LFP (admit-‚àß + AC-3), and M5 will wire Unanimity/Lattice + EngineWinner before you chase the remaining 100-ish tasks.
