Milestone spec you asked for—grounded in anchors, pure CS, no heuristics, receipts-first.

# Milestone M0 — “Bedrock” (after WO-00, WO-01, WO-03)

## Purpose

Stand up a minimal, deterministic **runner** that wires the foundational modules and proves byte-level correctness of (a) color-plane packing/unpacking and (b) frame canonicalization (D4 lex-min + anchor). No emits, no propagation, no selection, no size prediction.

---

## Scope (frozen)

### Modules that **must** be imported

* `core/registry.py` — `param_registry()`
* `core/receipts.py` — `Receipts`, double-run checker
* `core/bytesio.py` — grid/planes serializers (BE row-major)
* `kernel/planes.py` — `order_colors`, `pack_grid_to_planes`, `unpack_planes_to_grid`
* `kernel/ops.py` — `pose_plane`, `shift_plane` (used indirectly by frames)
* `kernel/frames.py` — `canonicalize`, `apply_pose_anchor`

### Runner contract (frozen shape; no feature flags yet)

```python
def solve(task_json: dict) -> tuple[list[list[int]], dict]:
    """
    M0 runner returns the test input grid unchanged as 'Y' (placeholder),
    plus a receipts bundle with sectioned hashes. No solving occurs.
    Steps:
      1) Build color universe C = {0} ∪ colors(X*) ∪ ⋃colors(X_i,Y_i)  (ascending ints)
      2) PACK→UNPACK identity check on all trainings and on X*
      3) Canonicalize frames (Π_in for all X_i and X*, Π_out for all Y_i)
      4) apply_pose_anchor round-trip proof on X* planes (pose∘inv == id; anchor idempotence)
      5) Seal receipts (no timestamps), run double-run equality check, return (Y_placeholder, receipts)
    """
```

**Note:** For M0, `Y_placeholder = X*` (identity). We are validating plumbing, not solving.

---

## Exact procedures (no optionality)

### 1) Color universe (A.1)

* Compute `C = {0} ∪ colors(X*) ∪ ⋃i colors(X_i) ∪ ⋃i colors(Y_i)`.
* `colors_order = sorted(C)` (ascending ints).
* **Receipts:** `color_universe` (list), `added_from_test` (list, possibly empty).

### 2) PACK↔UNPACK identity (WO-01)

For **each** grid `G` in `{X*, X_i, Y_i}`:

* `planes = pack_grid_to_planes(G, H, W, colors_order)`
* `G2 = unpack_planes_to_grid(planes, H, W, colors_order)`
* Assert `G2 == G` (byte-level equality).
* **Receipts per grid:**

  * `pack.hash_planes = blake3(serialize_planes_be_row_major(...))`
  * `pack.hash_grid   = blake3(serialize_grid_be_row_major(...))`
  * `pack.equal = (hash_planes == hash_grid)` must be `true`.

### 3) Canonical frames (WO-03; B.1)

For **each** grid `G` in `{X*, X_i, Y_i}`:

* `(pid, anchor, G_canon) = canonicalize(G)`
* Re-canonicalize `G_canon` and assert it yields `(pid="I", anchor=(0,0), same grid)`.
* Track `pose_tie_count`.
* **Receipts per grid:**

  * `frame.inputs = {H,W, colors_order, nonzero_count}`
  * `frame.pose   = {pose_id: pid, pose_tie_count}`
  * `frame.anchor = {r: ar, c: ac}`
  * `all_zero: bool`
  * `bytes.hash_before = blake3(winning_pose_bytes)`
  * `bytes.hash_after  = blake3(canon_grid_bytes)`
  * `idempotent: true`

### 4) Frame apply equivalence (planes ↔ grid) (WO-03)

For **X*** only (enough to prove wiring):

* `planes = pack_grid_to_planes(X*, H, W, colors_order)`
* `(planes2, H2, W2) = apply_pose_anchor(planes, pid, anchor, H, W, colors_order)` using the **X*** canonical frame.
* Unpack to `G2` and assert `G2 == G_canon` from step 3 (poses/anchor equivalence across APIs).
* **Receipts:** `apply.pose_id`, `apply.anchor`, `shape_before`, `shape_after`,
  `hash_planes_after == hash_grid_canon` must be `true`,
  `exclusivity_ok`, `overlap_zero`, `union_fullmask` (as recommended hardening).

### 5) Determinism (A.3)

* Run the entire `solve()` **twice** with the same input; ensure **every section hash** matches.
* If any mismatch: **FAIL** with `first_differing_section`.

---

## Invariants (must hold)

* **No heuristics, no floats, no RNG** anywhere.
* **No minted non-zero bits**: transforms act on positions only; background (0) emerges only from zero-fill, never from guessing.
* **Color exclusivity**: pack/unpack and pose/shift preserve “exactly one color per pixel” after transform.
* **Receipts-first**: every step logs BLAKE3 hashes over BE row-major bytes (frozen by WO-00).
* **Idempotence** of canonicalize: second pass produces `("I",(0,0), same)`.

---

## Failure modes (explicit)

* `SerializationError` / `ValueError` on shape mismatch, bit overflow, bad pid.
* `DeterminismError` if double-run hashes differ.
* **No UNSAT/SIZE errors** at M0 (those belong to later stages).
* On any failure: return **fail-closed** with a receipts bundle indicating which assertion tripped.

---

## Runner outputs at M0

* `Y_placeholder = X*` (identity grid).
* `receipts_bundle` containing sectioned receipts for:

  * `color_universe`
  * `pack_unpack` (per grid)
  * `frames.canonicalize` (per grid)
  * `frames.apply_pose_anchor` (X* proof)
  * `determinism` summary

---

## Reviewer quick-verification (real ARC; 1–2 lines)

* Pick 5 tasks; **every** training grid and X* must satisfy `pack↔unpack` identity and `canonicalize` idempotence; `apply_pose_anchor`(planes) must reconstruct `G_canon` for X*.
* Double-run hashes must be identical across all sections.

---

### Do any of the earlier pitfalls apply to M0?

Only two wiring pitfalls to watch:

1. **Color universe must include test colors** (A.1). If you omit `colors(X*)`, PACK/UNPACK may reject cells.
2. **Bit mapping conventions** must be consistent: planes use bit j = column j; serializers emit BE bytes with bit7→col0 … bit0→col7. If mismatched, your hash cross-checks will fail.

No LCM, no size prediction, no majority anything at M0—so none of those pitfalls apply yet.

---

## Developer checklist (Implementer)

* Implement `solve()` exactly as above; **no feature flags yet**, no stubs.
* Use only the specified modules; no extra “helpers.”
* Emit receipts per step with WO-00; run the double-run equality check; raise on mismatch.

## Notes for later milestones

* Keep this runner file; **do not replace it**. For M1+ we’ll only append new sections (size prediction, emitters, LFP, selection), keeping M0 sections unchanged and re-verifiable.

That’s it—once M0 is green on your curated ARC slice, we’ve locked the byte-level substrate and can safely layer size prediction and admits.
