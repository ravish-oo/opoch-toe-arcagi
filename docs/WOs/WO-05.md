WO-05 you asked for—grounded in v1.5 + v1.6, pure CS primitives, receipts-first, and no wiggle room.

# WO-05 — 4-CC Components & Shape Invariants (bit-ops only)

## Purpose

From per-color bit-planes, extract **4-connected** components (skip background 0 by default) and compute per-component invariants:

* bounding box (bbox),
* area (pixel count),
* 4-neighbor perimeter (perim4),
* **D4-minimal shape hash** (translation-free; “outline hash” in the math spec).

No heuristics, no floats, no search beyond the finite mask growth.

---

## Inputs & representation (frozen)

* `planes: Dict[int, List[int]]` — for each color `c`, a list of `H` row masks (Python ints), with **bit j = column j** and **(mask >> W) == 0** (WO-01 convention).
* `H, W: int` — grid shape.
* `colors_order: List[int]` — ascending integers, includes 0 (WO-00/WO-01).
  **By default, components for color 0 are skipped** (background); see Edge cases.

---

## Interface (pure; exact types; no optional args)

```python
from typing import Dict, List, Tuple, TypedDict

class Component(TypedDict):
    color: int
    bbox: Tuple[int,int,int,int]     # (r_min, c_min, r_max, c_max), inclusive
    mask_plane: List[int]            # H-length row masks for THIS component (bits within bbox rows only; outside rows MUST be 0)
    area: int
    perim4: int
    outline_hash: str                # BLAKE3 hex of D4-min cropped bytes (see below)

def components(planes: Dict[int, List[int]], H: int, W: int, colors_order: List[int]) -> List[Component]:
    """
    Returns all 4-CC components for colors in colors_order EXCEPT color 0.
    Components are disjoint within each color; union of all component masks
    equals the original plane exactly for that color.
    Raises ValueError if row lengths != H or any mask has bits outside [0..W-1].
    """
```

---

## Exact algorithm (no ambiguity)

### A) Validate inputs

* For every plane:

  * `len(plane) == H`
  * For each row mask `m`: assert `(m >> W) == 0`.

### B) For each color `c` in `colors_order` **except 0**

1. **Residual mask `R` := copy of planes[c]** (rowwise ints).
2. While `R` has any non-zero row:

   * **Seed:** find first row `r` with `R[r] != 0`; let `c0 = lsb_index(R[r])` (least bit set).
     Initialize component mask `C` to all zeros; initialize frontier `F` as a zero rowlist except `F[r] = (1 << c0)`.
   * **Grow (4-neighbor BFS by bit-ops)** until `F` becomes all zeros:

     * Horizontal neighbors (same row):
       `Hnb[r] = ((F[r] << 1) | (F[r] >> 1)) & ((1 << W) - 1)`
     * Vertical neighbors:
       For each row `r`:
       `Vnb[r] = (r>0 ? F[r-1] : 0) | (r+1<H ? F[r+1] : 0)`
     * **Union & constrain to this color’s mask and not-yet-visited:**
       `N[r] = (Hnb[r] | Vnb[r]) & R[r]`
     * **Update component and frontier:**
       `C[r] |= F[r]` for all rows; `F := N`.
   * **Commit component & remove from residual:**
     For all rows: `R[r] &= ~C[r]`.
   * **Compute invariants** for this `C` (below) and append a `Component`.

**Why this works:** Growth is monotone, bounded by `R`, deterministically terminates in ≤ area steps. Every pixel is assigned to exactly one component per color.

### C) Invariants for a component mask `C` (bit-exact)

1. **Area**: `area = Σ_r popcount(C[r])`.

2. **BBox**:

   * `r_min = min { r | C[r] != 0 }`, `r_max = max { r | C[r] != 0 }`.
   * `c_min` = minimum bit index present in any row in `[r_min..r_max]`.
   * `c_max` = maximum bit index present in any row in `[r_min..r_max]`.
     (All inclusive; if single pixel, `r_min=r_max`, `c_min=c_max`.)

3. **Perimeter (4-neighbor)** — exact integer formula, no loops over neighbors:

   * Let `U = Σ_r popcount(C[r])` (area).
   * Shared vertical edges: `Sv = Σ_r popcount( C[r] & C[r-1] )` for `r=1..H-1`.
   * Shared horizontal edges: `Sh = Σ_r popcount( (C[r] & (C[r] << 1)) )` for all rows (left adjacency).
   * **Perimeter:** `perim4 = 4*U - 2*(Sv + Sh)`.
     (Each shared edge removes 2 from the sum of pixel perimeters.)

4. **D4-minimal shape hash (“outline hash”)** — translation-free, rotation/flip-canonical:

   * **Crop to bbox** (remove all-zero rows/cols outside `[r_min..r_max] × [c_min..c_max]`, keep interior zeros). Call this cropped mask `C_crop` with shape `(Hc, Wc)`.
   * For each D4 pose `pid ∈ ["I","R90","R180","R270","FX","FXR90","FXR180","FXR270"]`:

     * Apply WO-01 `pose_plane` to `C_crop` (rectangular-aware).
     * **Re-crop** again to remove any new outer all-zero borders (some rotations introduce them).
     * Serialize to bytes with WO-00 format: Header 2×uint16 `Hc', Wc'` (BE), then row-major BE bit payload for this single color plane (others are absent here).
   * Take the **lexicographically smallest** of those 8 byte streams; compute **BLAKE3** hex digest.
   * **outline_hash =** that digest.

5. **mask_plane** storage (component plane):

   * Produce an **H-length** row mask list where:

     * Rows `r_min..r_max` contain the bits of `C[r]` **(unaltered, i.e., original columns)**.
     * Rows outside bbox are **0**.
       This keeps the original coordinate frame and makes “union of component masks == original plane” easy to assert downstream.

---

## Invariants to assert (and how to check)

* **No minted bits:** For each color, OR of all component masks equals the original plane **exactly**; pairwise AND between any two components’ row masks is **0**.
* **Termination bound:** The loop over seeds strictly shrinks `R` (at least one bit cleared per component).
* **Determinism:** First seed is **row-major earliest** bit; BFS is purely bit-ops—same inputs yield identical components and ordering (by discovery).
* **Perimeter correctness sanity checks:**

  * area=1 ⇒ perim4=4
  * a 1×k horizontal run ⇒ perim4 = 2 + 2k
  * a k×1 vertical run ⇒ perim4 = 2 + 2k

---

## Failure modes (explicit)

* Raise `ValueError` if any plane row count ≠ H or any row mask has bits outside `[0..W-1]`.
* If a color has no bits set: produce **0 components** (do not synthesize anything).

---

## Receipts (first-class; algebraic)

Section name: `"components"` (one section per call). **All additive; don’t remove or rename later.**

**Required:**

* `inputs`: `{ "H":H, "W":W, "colors_order": [...], "include_background": false }`
* `per_color_summary`: array in `colors_order` (excluding 0 by default); each:

  ```json
  {
    "color": c,
    "n_cc": int,
    "area_sum": int,
    "area_min": int|null,
    "area_max": int|null,
    "perim4_sum": int          // sum over components, useful cross-check
  }
  ```
* `components`: array of:

  ```json
  {
    "color": c,
    "bbox": [r_min,c_min,r_max,c_max],
    "area": area,
    "perim4": perim4,
    "outline_hash": "blake3hex"
  }
  ```

  (We omit raw `mask_plane` in receipts to keep logs compact; it’s in memory for callers.)
* `union_equal_input`: bool  // for each color, union(component masks) == planes[c]
* `overlap_zero`: bool       // for each color, pairwise overlaps == 0
* `section_hash`: string     // BLAKE3 over stable JSON (WO-00)

**Optional (debug anchors, still additive):**

* `per_color_row_popcounts`: list of per-row popcount sums (helps bisect diffs fast).

---

## Edge cases (fully specified)

* **Single-pixel component**: bbox is that cell; area=1; perim4=4; outline hash is the D4-min of a 1×1 mask.
* **Line components**: handled by perimeter formula; outline hash reduced by D4.
* **All-zero plane for a color**: no components; per_color_summary has `n_cc=0`, `area_sum=0`, `area_min/max=null`.
* **Background color 0**: by default **excluded**; if you later want to include, guard it with a param flag and add a receipts field `include_background:true` (add-only change).

---

## What’s explicitly out of scope

* Any palette/color logic (colors are original ints; 0 excluded by default).
* Any post-processing that mutates components (no merge/split heuristics).
* Any D4 pose choice beyond the outline hash computation (canonicalization of grids belongs to WO-03).

---

## Developer checklist (Implementer)

* Implement bit-BFS growth exactly as above (H- and V-neighbors by shifts), constrained to residual `R`.
* Compute area, bbox, perim4 via the exact bit formulas.
* Compute D4-minimal shape hash by: **pose→re-crop→serialize→lex-min→BLAKE3**.
* Assert union/overlap invariants per color before returning.
* Emit receipts with the required fields only; no timestamps; determinism check belongs to caller.

---

## Reviewer quick-verification (real ARC; 1–2 lines)

* On a few training grids, union of component masks per color equals the input plane and pairwise overlaps are zero; perim4 sanity (single pixel=4; 1×k run = 2+2k) holds.
* D4-minimal `outline_hash` for a shape equals the hash of any rotated/reflected copy of that shape.

---

**Spec grounding:**

* Components/invariants are used in v1.5 (§4.1 evidence; outline D4-min hash) and feed WO-14 features (per-color `n_cc` and area stats).
* All operations are finite bit algebra on at most 30×30 masks—no heuristics, no search, purely deterministic, receipts-first.
