WO-11 you asked for—frozen to our v1.6 math + addendum. It uses only core CS primitives (bitsets, fixed graph, textbook AC-3), is fully deterministic, and receipts-first. No heuristics.

# WO-11 — Domain Tensor & LFP Propagator

## Purpose

Compute the **least fixed point** (LFP) of the current constraints on the working canvas:

1. **Admit-intersect** all enabled emitters in a **frozen family order** (T1…T12) with scope gating.
2. **AC-3 prune** with the learned forbids (M) on the fixed 4-neighbor graph.
3. Repeat until **no bit changes**. Fail-closed on empty domains or if a hard iteration cap is reached.

---

## Inputs (frozen)

* `D0` — initial **domain tensor** on ((R_{out},C_{out})): per-pixel **bitmask** over `colors_order`.
  Representation (frozen):

  ```python
  D0: Dict[Tuple[int,int], int]  # (r,c) -> bitmask over colors_order (LSB = colors_order[0])
  ```

  Typical `D0` for propagation start is **all ones** (every color allowed) or output from a prior stage.

* `emitters_list` — an **ordered list** of admit layers already computed on the working canvas (each in our (A,S) form):

  ```python
  emitters_list = [
    ("T1_witness",   A_wit, S_wit),
    ("T2_unity",     A_uni, S_uni),
    ("T3_lattice",   A_lat, S_lat),
    ("T4_kron",      A_kron, S_kron),
    ("T5_conv",      A_conv, S_conv),
    ("T6_morph",     A_morph, S_morph),
    ("T7_logic",     A_logic, S_logic),
    ("T8_param",     A_param, S_param),
    # T9 is size; no admits
    ("T10_forbids",  None, None),  # placeholder; AC-3 consumes forbids separately
    ("T11_csp",      A_csp, S_csp),
    ("T12_strata",   A_extra, S_extra),
  ]
  ```

  **Frozen family order** is exactly T1..T12; you **must** preserve this order when present. Any missing family is simply skipped.

  Each `A` is a `Dict[color -> List[int]]` of row-masks (per-color plane), and each `S` is `List[int]` (scope row-masks), as defined earlier (WO-07/08/09/16x).

* `forbids` — optional tuple from WO-10: `E_graph` (directed 4-neighbor arcs) and `M_matrix` (forbid matrix).

* `colors_order` — ascending int list (includes 0).

* `caps` (frozen defaults):

  * `MAX_PROPAGATION_ITERATIONS = 1000` (hard cap guard)

---

## Interface (pure; receipts-first)

```python
from typing import Dict, Tuple, List, Optional, TypedDict

class LFPStats(TypedDict):
    admit_passes: int
    ac3_passes: int
    total_admit_prunes: int     # sum of bits removed by admits across all passes
    total_ac3_prunes: int       # sum of prunes from AC-3 across all passes
    empties: int                # last pass empties (signals UNSAT upstream)
    domains_hash: str           # hash of final D (or D before UNSAT)
    section_hash: str

def lfp_propagate(
    D0: Dict[Tuple[int,int], int],                          # initial domain tensor
    emitters_list: List[Tuple[str, Dict[int,List[int]], List[int]]],
    forbids: Optional[Tuple[List[Tuple[int,int,int,int]], Dict[int, set]]] = None,
    colors_order: List[int] = None,
) -> Tuple[Dict[Tuple[int,int], int], LFPStats] | Tuple[str, LFPStats]:
    """
    Run the monotone loop:
      while changes:
        1) admit-intersect in frozen family order (scope-gated)
        2) AC-3 prune (if forbids present)
    Early exit on empty domain → return ("UNSAT", stats).
    Fail-closed if cap reached → ("FIXED_POINT_NOT_REACHED", stats).

    Returns:
      (D*, stats) on success, or ("UNSAT"/"FIXED_POINT_NOT_REACHED", stats)
    """
```

---

## Exact algorithm

### 0) Helpers (frozen)

* **Color bit**: for color `colors_order[k]`, `BIT[k] = (1 << k)`.

* **Emit plane → pixel mask**: at pixel `(r,c)` (bit = (1 \ll c)):
  ( \text{AdmitMask}*{A}(r,c) = \bigvee*{k} \big( A[color_k][r] & bit \ ?\ 1 \ll k : 0 \big) ).
  If `(S[r] & bit) == 0`, this emitter is **silent** at `(r,c)` (no constraint).

* **Domain intersect at pixel**:
  If `S[r]&bit`: `D[r,c] &= AdmitMask_A(r,c)`. Else no-op.
  Count `admit_prunes` as the number of bits cleared.

* **Domains hash**: pack `D` to a stable bytes stream in row-major, for each `(r,c)` write `domain_bitmask.to_bytes(ceil(K/8),"big")`, prefix once with `(R_out,C_out,K)` for canonicality; BLAKE3.

### 1) The loop (monotone; frozen order T1..T12)

```
D = copy(D0)
admit_passes = ac3_passes = 0
total_admit_prunes = total_ac3_prunes = empties = 0

for iter_idx in 1..MAX_PROPAGATION_ITERATIONS:
    changed = False

    # (1) Admit pass in frozen family order
    admit_prunes_this = 0
    for family, A, S in emitters_list:
        if family == "T10_forbids":   # not an admit layer
            continue
        if not A or not S:            # absent / empty → skip
            continue

        # Scope-gated intersect
        for r in 0..R_out-1:
            scope_row = S[r] if r < len(S) else 0
            if scope_row == 0:
                continue
            for c in 0..C_out-1:
                bit = 1 << c
                if not (scope_row & bit):
                    continue

                # Build admit bitmask at (r,c) from color planes
                admit_mask = 0
                for k, col in enumerate(colors_order):
                    plane = A.get(col, None)
                    if plane and r < len(plane):
                        if (plane[r] & bit) != 0:
                            admit_mask |= (1 << k)

                # Intersect if non-empty; if empty, leave it (it prunes to 0 below)
                old = D[(r,c)]
                new = old & admit_mask
                if new != old:
                    D[(r,c)] = new
                    admit_prunes_this += bin(old ^ new).count("1")

    admit_passes += 1
    total_admit_prunes += admit_prunes_this
    changed = changed or (admit_prunes_this > 0)

    # Early UNSAT check (any empty domain)
    empties = sum(1 for rc,mask in D.items() if mask == 0)
    if empties > 0:
        # Return UNSAT with stats up to this point
        return "UNSAT", _seal_stats(admit_passes, ac3_passes, total_admit_prunes, total_ac3_prunes, empties, D)

    # (2) AC-3 prune (if forbids present)
    if forbids is not None:
        changed_ac3, ac3_stats = ac3_prune(D, E_graph, M_matrix, colors_order)
        ac3_passes += 1
        total_ac3_prunes += ac3_stats["prunes"]
        empties = ac3_stats["empties"]
        changed = changed or changed_ac3

        if empties > 0:
            return "UNSAT", _seal_stats(admit_passes, ac3_passes, total_admit_prunes, total_ac3_prunes, empties, D)

    # Fixed point?
    if not changed:
        return D, _seal_stats(admit_passes, ac3_passes, total_admit_prunes, total_ac3_prunes, 0, D)

# Cap guard
return "FIXED_POINT_NOT_REACHED", _seal_stats(admit_passes, ac3_passes, total_admit_prunes, total_ac3_prunes, 0, D)
```

> **Why it’s correct:** Each admit intersect and AC-3 prune is a **monotone** operator on the finite lattice (({0,1}^K)^{R\times C}); the loop descends and must stabilize. The cap is a guard for coding errors—fail-closed if ever reached.

---

## Invariants & determinism (must hold)

* **Frozen family order**: T1→T12 admit layers are applied in exactly that sequence every pass.
* **Scope-gating**: intersect only where `S[r]&bit==1`; silent elsewhere.
* **No admits for T10**: forbids are applied **only** via AC-3.
* **Queue order (AC-3)**: E_graph directed arcs are row-major; FIFO processing; neighbors enqueued in the same frozen order; see WO-10.
* **Early UNSAT**: any `D[(r,c)] == 0` mid-pass aborts with `UNSAT`.
* **Cap guard**: `FIXED_POINT_NOT_REACHED` if the loop hits `MAX_PROPAGATION_ITERATIONS`.
* **Deterministic receipts**: `domains_hash` must match on double-run.

---

## Receipts (first-class; additive; stable)

`LFPStats` section (sealed):

* `admit_passes` (int ≥ 1)
* `ac3_passes` (int ≥ 0)
* `total_admit_prunes` (int)
* `total_ac3_prunes` (int)
* `empties` (int; >0 for UNSAT)
* `domains_hash` (BLAKE3 over canonical row-major domain bytes)
* `section_hash`

> You can optionally add per-family admit prune counts (add-only) to pinpoint which layer cut most; keep the base schema intact.

---

## Edge cases (fully specified)

* **No emitters**: admit pass is a no-op; only AC-3 runs (if present).
* **No forbids**: AC-3 step skipped entirely; fixed point reached when no admit changes.
* **Singleton everywhere**: the first pass often converges (prunes zero) and will return immediately.
* **Empty domain immediately**: if `D0` already has an empty pixel, return `UNSAT` with `admit_passes=1` and `total_admit_prunes=0`.

---

## What’s explicitly out of scope

* Any selection/action on `D*` (that’s WO-13).
* Any “engine arbiter” decision among families (that’s WO-12).
* Any non-local search/backtracking (AC-3 only, no CSP tree here).

---

## Developer checklist (Implementer)

* Implement per-pixel bitmask domains; use `BIT[k]` for color manip.
* Implement scope-gated intersect exactly; count **bit** prunes (not pixel prunes).
* Wire **WO-10 AC-3** with the frozen queue; return its stats; add to totals.
* Hash `D` at the end (or at UNSAT) via the canonical row-major byte stream; BLAKE3.
* Enforce cap and UNSAT early exit; seal receipts; double-run determinism test.

---

## Reviewer quick-verification (real ARC; 1–2 lines)

* On a toy where witness+unanimity force many pixels, verify convergence in ≤ 3 passes and `domains_hash` stable on double-run.
* On a crafted UNSAT (forbids rule contradicts a singleton), verify early `UNSAT` with `empties>0` and consistent `admit_passes/ac3_passes` in receipts.
