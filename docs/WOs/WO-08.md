WO-08 you asked for, updated to **v1.6 (single working canvas, no LCM)** and aligned with our existing WOs. It uses only core CS operations (integer Kronecker replication, exact block-constancy decimation, D4 pose+anchor transport), is fully deterministic, and emits receipts you can audit. No heuristics, no stubs.

# WO-08 — Output Transport & Unanimity Emitters (v1.6)

## Purpose

For each training output (Y_i):

1. **Normalize to the working canvas** ((R_{\text{out}}, C_{\text{out}})) by **integer replication** or **exact block-constancy decimation**; else mark the training **silent**.
2. **Transport** the normalized (Y_i^\uparrow) into the **test output frame** (\Pi_{\text{out}}^*) (pose+anchor) and emit a per-training layer ((A^{\text{out}}_i, S^{\text{out}}_i)) of **hard color admits** (singletons).
3. **Unanimity**: at each pixel (p), if all **included** trainings agree on the same color (u), emit (A^{\text{uni}}[p]={u}) with (S^{\text{uni}}[p]=1); otherwise **silent** at (p).

> **No LCM canvas** anywhere. All admits live on the single working canvas, and all transports target (\Pi_{\text{out}}^*).

---

## Interfaces (pure; no I/O; receipts-first)

```python
from typing import List, Dict, Tuple, Optional, TypedDict

class TransportReceipt(TypedDict):
    train_id: int
    norm_kind: str                 # "replicate" | "decimate" | "silent"
    s_r: Optional[int]             # row factor if replicate/decimate, else null
    s_c: Optional[int]
    block_constancy_ok: Optional[bool]  # true only for decimate when verified
    pose_src: str                  # Π_out_i.pose_id
    anchor_src: Tuple[int,int]     # Π_out_i.anchor
    pose_dst: str                  # Π_out*.pose_id
    anchor_dst: Tuple[int,int]
    scope_bits: int
    transport_hash: str            # blake3 of transported color planes on (R_out,C_out)

def emit_output_transport(
    Y_list: List[List[List[int]]],                # raw training outputs (each H_i x W_i)
    frames_out: List[Tuple[str, Tuple[int,int]]], # Π_out_i for each training: (pose_id, anchor)
    R_out: int, C_out: int,                       # working canvas (from WO-04a)
    colors_order: List[int],                      # ascending ints (includes 0)
    pi_out_star: Tuple[str, Tuple[int,int]]       # Π_out* (pose_id, anchor)
) -> Tuple[List[Dict[int, List[int]]], List[List[int]], List[TransportReceipt], Dict]:
    """
    Returns:
      A_out_list : list of per-training dict color->H_out row-masks (singletons)
      S_out_list : list of per-training H_out-length scope masks (1 where training speaks)
      per_train_receipts : list of TransportReceipt
      section_receipt : {"transports_hash": blake3, "n_included": k, ...}
    """
```

```python
class UnanimityReceipt(TypedDict):
    included_train_ids: List[int]
    unanimous_pixels: int
    total_covered_pixels: int
    empty_scope_pixels: int        # #p with no included training speaking
    unanimity_hash: str            # blake3 over A_uni
    scope_hash: str                # blake3 over S_uni

def emit_unity(
    A_out_list: List[Dict[int, List[int]]],
    S_out_list: List[List[int]],
    colors_order: List[int],
    R_out: int, C_out: int
) -> Tuple[Dict[int, List[int]], List[int], UnanimityReceipt]:
    """
    Returns:
      A_uni : dict color->H_out row-masks (singleton admits at unanimous pixels)
      S_uni : H_out-length scope mask (1 where unanimous)
      receipt : UnanimityReceipt
    """
```

> If you prefer the original names, alias `emit_unity` to `emit_unanimity`; just keep the above semantics.

---

## Exact algorithms (frozen)

### 1) Normalize each (Y_i) to ((R_{\text{out}}, C_{\text{out}}))

Let ((H_i, W_i) = \text{shape}(Y_i)).

* **Replicate (integer upsample)** if (R_{\text{out}} = s_r H_i) and (C_{\text{out}} = s_c W_i) with integers (s_r, s_c \ge 1):
  Set (Y_i^\uparrow[r,c] = Y_i\big(\lfloor r/s_r \rfloor, \lfloor c/s_c \rfloor\big)).
  (Kronecker product with an (s_r \times s_c) all-ones block per color.)

* **Decimate (exact block-constancy downsample)** if (H_i = s_r R_{\text{out}}) and (W_i = s_c C_{\text{out}}) with integers (s_r, s_c \ge 1):
  Require **every** (s_r \times s_c) block in (Y_i) be **constant**. If any block contains >1 color → **silent** for this training.
  Otherwise set (Y_i^\downarrow[r,c] = \text{that block’s color}).

* **Else (no exact integer relation)**: **silent** for this training (no normalization; it cannot speak on this canvas).

> **Receipts** must record `norm_kind`, `s_r/s_c`, and `block_constancy_ok` for decimate.

### 2) Transport normalized output to the test output frame (\Pi_{\text{out}}^*)

Let (\Pi_{\text{out}}^i = (\text{pose}_i, \text{anchor}*i)) be the training’s output frame; (\Pi*{\text{out}}^* = (\text{pose}^*, \text{anchor}^*)) is the test output frame (both rectangular-aware D4+shift, per WO-03).

* For each color (c \in \mathcal C), build the row-mask plane of (Y_i^{\uparrow/\downarrow}) in its **own** pose (\Pi_{\text{out}}^i): `planes_i[c]` (H_out x row-masks).

* Compute the transform (T_i = \Pi_{\text{out}}^* \circ U(\Pi_{\text{out}}^i)).
  Apply to each color plane: (A^{\text{out}}_{i,c} = \text{pose_plane}( \text{shift_by}; -\text{anchor}_i, \text{pose}*i ) \stackrel{T_i}{\longrightarrow} \Pi*{\text{out}}^*). In code:

  1. **Unanchor** source: shift rows by (-\text{anchor}_i).
  2. **Pose** by (\text{pose}_i \to \text{pose}^*) (compose to a single D4 from source to dest).
  3. **Re-anchor** at (\text{anchor}^*) (shift).
     Use `pose_plane` for D4, `shift_plane` for integer translations; guard shapes with correct swap sets (`R90/R270/FXR90/FXR*270` swap H/W; **`FXR180` does not**).

* **Scope**: (S^{\text{out}}_i[r]) has bit (1) at column (c) iff **some** color plane sets that bit (equivalently the pixel is defined in (Y_i^{\uparrow/\downarrow}) after transport).
  Since each normalized cell is a **single color**, the per-pixel admit set is a singleton `{u}` if included; it is **never all-colors**, so no pixel-wise “admit-all ⇒ silent” occurs here. If the training is **silent** (no normalize), set (S^{\text{out}}_i = 0) and do not emit per-color planes (or leave them all zeros).

**Per-training receipts:** fill `TransportReceipt` and an overall `transports_hash = blake3( concat of per-train transport hashes )` and `n_included`.

### 3) Unanimity

Given (A^{\text{out}}_i, S^{\text{out}}_i) for all trainings:

* For each pixel (p=(r,c)), let (\mathcal I_p = { i : S^{\text{out}}_i[r]\text{ has bit }c }).

  * If (\mathcal I_p = \varnothing), set (S^{\text{uni}}[p]=0) (silent), and **do not** emit any color at (p).
  * Else, collect the set (U_p = {, u_i : A^{\text{out}}_{i,u_i}[p]=1, i\in \mathcal I_p ,}).

    * If (|U_p| = 1) (singleton ({u})): set (S^{\text{uni}}[p]=1), (A^{\text{uni}}*u[p]=1), and all other (A^{\text{uni}}*{c\neq u}[p]=0).
    * Otherwise (disagreeing trainings): (S^{\text{uni}}[p]=0) and **do not** restrict admits (i.e., leave (A^{\text{uni}}) all-zeros; the selector will skip this bucket).

* **No admit-all at unanimity pixels** (they are singletons). Where **not** unanimous, `S_uni` is zero; we never set “all colors” at (\neg S^{\text{uni}}) pixels.

**Unanimity receipts:** `included_train_ids`, `unanimous_pixels` (popcount of `S_uni`), `total_covered_pixels` (popcount of ({p: |\mathcal I_p|>0})), `empty_scope_pixels` (= total_canvas − total_covered), `unanimity_hash`, `scope_hash`.

---

## Invariants (must hold)

* **No minted bits**: replication is a true Kronecker; decimation only on constant blocks; transport is pure D4+shift; unanimity emits a singleton only when all included trainings agree.
* **Trainings-only**: inclusion (replicate/decimate/silent) is decided solely from (Y_i) and ((R_{\text{out}},C_{\text{out}})); unanimity uses **included** trainings only.
* **Determinism**:

  * Family/bounds of normalization are fixed;
  * D4 pose order and rectangular swaps are frozen (`R90/R270/FXR90/FXR270` swap H/W; `FXR180` does not);
  * Receipts list which trainings spoke and the exact bytes hashed.
* **Admit-all ⇒ silent**: only relevant if a training is silent; in that case `S_out_i = 0` (no spurious scope).

---

## Failure modes (explicit)

* If a training cannot be normalized (neither replicate nor exact decimate) → mark it **silent** in `TransportReceipt`, `scope_bits=0`, and **do not contribute** to unanimity.
* If decimation block-constancy check fails → `norm_kind="decimate"`, `block_constancy_ok=false`, treat as **silent** (no contribution).

No exception should be raised for “legit silent”; you always return `A_out_list`, `S_out_list`, and a `section_receipt`.

---

## Receipts (first-class; additive; stable)

**Transport section** (one per task):

```json
{
  "transports": [
    {
      "train_id": 0,
      "norm_kind": "replicate",
      "s_r": 2, "s_c": 3, "block_constancy_ok": null,
      "pose_src": "R90", "anchor_src": [0,0],
      "pose_dst": "I", "anchor_dst": [0,0],
      "scope_bits": 324,
      "transport_hash": "…"
    },
    { "train_id": 1, "norm_kind": "silent", "s_r": null, "s_c": null, "block_constancy_ok": null, ... }
  ],
  "n_included": 1,
  "transports_hash": "…",
  "section_hash": "…"
}
```

**Unanimity section**:

```json
{
  "included_train_ids": [0],
  "unanimous_pixels": 312,
  "total_covered_pixels": 324,
  "empty_scope_pixels": 36,
  "unanimity_hash": "…",
  "scope_hash": "…",
  "section_hash": "…"
}
```

> **Determinism**: all hashes via BLAKE3 over BE row-major bytes per WO-00. Double runs must match.

---

## Edge cases (fully specified)

* **All trainings silent**: `A_out_list` empty planes; `S_out_list` all zeros; unanimity emits `S_uni=0` and `A_uni` all zeros; `unanimous_pixels=0`, `total_covered_pixels=0`.
* **One-sided period cases**: If only one axis replicates/decimates and the other doesn’t divide, training is **silent** (cannot map exactly to the working canvas).
* **Mismatched poses**: transport still works—pose with D4 and anchor shift; no guessing.

---

## What’s explicitly out of scope

* Any value synthesis (e.g., “compute color as function of input”): this is **unanimity**, not value mapping.
* Any domain propagation (AC-3 / LFP): WO-11.
* Any EngineWinner selection: WO-12.

---

## Developer checklist (implementer)

* Implement a pure integer **replicate** (Kronecker) and **decimate** with strict block-constancy; otherwise mark *silent*.
* Implement D4 pose/anchor transport with the **correct swap set** (only 90°/270° and their FX variants swap H/W).
* Build per-training `A_out_i` as **singleton** per pixel; `S_out_i` is their union; silence if not normalized.
* Compute unanimity exactly as the intersection of colors among **included** trainings; `S_uni=1` only on singleton points; no admit-all anywhere.
* Emit receipts as specified; ensure double-run hashes are equal.

---

## Reviewer quick-verification (real ARC; 1–2 lines)

* On a mixed-size task where all trainings are upsample-compatible to the working canvas, check `transports.n_included == #trainings`, `block_constancy_ok` only for decimates, and `unanimous_pixels > 0`.
* On a stripes task with contradictory outputs, verify `included_train_ids` are non-empty but `unanimous_pixels` drops where colors disagree; no “admit-all” scope.

---

**Pitfall resolved:** This WO **replaces LCM** with **per-training normalization to the single working canvas** (replicate, exact decimate, or silent). Unanimity then operates only where at least one normalized training speaks; it emits a singleton color **only** when all speaking trainings agree.
