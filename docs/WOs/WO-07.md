WO-07 you asked for—grounded in the v1.5 spec + Patch v1.6 and our prior WOs. It makes no heuristic choices, uses only core CS primitives (bit-ops + fixed affine composition), and emits **receipts-first** outputs.

# WO-07 — Conjugation & Forward Witness Emitter

## Purpose

Take the per-training **witness results** from WO-06 (rigid pieces ( \phi_i=(R_i,t_i) ) and partial recolor maps ( \sigma_i )) and:

1. **Conjugate** every accepted piece from its training frames ((\Pi^{in}*i,\Pi^{out}*i)) to a single **working output canvas** (\Pi^{out}**) and the **test input engine frame** (\Pi^{in}**).
2. **Forward-emit** admissible colors at target pixels by transporting the test input bit-planes (B_c(X^*)) through each conjugated piece and recoloring with (\sigma_i).
3. Produce one global **witness emitter** ((A^{\text{wit}}, S^{\text{wit}})) by scope-gated intersection across trainings (admit-all outside each training’s scope).

No LCM appears anywhere; all emission is on ((R_{\text{out}},C_{\text{out}})) chosen at WO-04a.

---

## Inputs (frozen)

* `X_star`: test input grid (raw integers).
* `witness_results_all_trainings`: list of `WitnessResult` from WO-06, one per training (i). Each contains:

  * `pieces`: list of dicts `{"pid":str,"dy":int,"dx":int,"bbox_src":(rmin,cmin,rmax,cmax),"bbox_tgt":(rmin,cmin,rmax,cmax),"c_in":int,"c_out":int}`
  * `sigma`: dict `{ color_in:int -> color_out:int }` (partial bijection on touched colors)
  * `silent`: bool
* `frames`: a struct holding the four fixed frames (from WO-03 and runner):

  * `Pi_in_star = (R_in*, a_in*)`  — test input engine frame (pose+anchor)
  * `Pi_out_star = (R_out*, a_out*)` — working output canvas frame (pose+anchor), shape ((R_{\text{out}},C_{\text{out}}))
  * for each training (i): `Pi_in_i = (R_in^i, a_in^i)`, `Pi_out_i = (R_out^i, a_out^i)`

**Frame algebra (frozen; WO-03 / §5.1):**

* A frame is an affine isometry ( \Pi=(R,a) ) with (R\in D_4) and (a\in\mathbb Z^2).
* Composition: ( (R_1,a_1)\circ(R_2,a_2) = (R_1R_2,\ R_1 a_2 + a_1) ).
* Inverse: ( (R,a)^{-1} = (R^{-1},\ -R^{-1} a) ).

**Conjugation (frozen):**
Each WO-06 piece ( \phi_i=(R_i,t_i)) maps **from** (\Pi^{in}*i) coords **to** (\Pi^{out}*i) coords: (p*{out}=R_i p*{in}+t_i).
To act on test input and land on the working canvas, define
[
\boxed{ ;\phi_i^* ;=; \Pi^{out}** \circ \Pi^{out}*i{}^{-1} \circ \phi_i \circ \Pi^{in}*i \circ \Pi^{in}**{}^{-1}; }
]
so (p**^{out} = \phi_i^*(p**^{in})). This is one affine map ((R^*,t^*)) via the above composition law.

---

## Interface (pure; exact signature)

```python
from typing import Dict, List, Tuple

def emit_witness(
    X_star: List[List[int]],
    witness_results_all_trainings: List[dict],
    frames: dict,
    colors_order: List[int],          # ascending ints, includes 0 and colors(X*)
    R_out: int, C_out: int            # working canvas shape from WO-04a
) -> Tuple[Dict[int, List[int]], List[int]]:
    """
    Returns:
      A_wit : dict color->plane (H=R_out rows of W=C_out-bit masks), the scope-gated INTERSECTION across trainings
      S_wit : list[int] row masks (length R_out), scope = union of target bboxes of all conjugated pieces across trainings,
              after per-training admit-all normalization.
    All emission and shapes are in Pi_out* coordinates (the single working canvas).
    """
```

---

## Exact algorithm

### 0) Prepare test input planes (in (\Pi^{in}_*))

* Canonicalize `X_star` to (\Pi^{in}_*) using WO-03 `apply_pose_anchor` → `planes_in_star: {c -> [row_masks len=H_in*]}`.
* Ensure `colors_order` contains `{0} ∪ colors(X*) ∪ ⋃colors(X_i,Y_i)`.

### 1) For each training (i), build a **per-training emitter** ((A_i, S_i))

If `witness_results_all_trainings[i]["silent"]` is `True` **or** its `pieces` empty:

* Set `S_i = [0]*R_out` and **admit-all** outside scope by defining (A_i[c] = \mathbf{1}^{R_{\text{out}}\times C_{\text{out}}}) for **every** color (c\in \mathcal C). (Equivalently: in the global intersection step, we’ll AND with ((S_i?A_i:\text{all})) so a silent training imposes **no constraint**.)

Else:

* Initialize `S_i = [0]*R_out` and (A_i[c] = \text{all-ones mask (length R_out, width C_out)}) for every (c) (we’ll **AND in** per-piece contributions).

* For each **accepted** piece `p ∈ pieces_i`:

  * Read `pid, dy, dx, bbox_src, c_in, c_out` and derive (\phi_i=(R_i,t_i)) in ((\Pi^{in}_i\to \Pi^{out}_i)).
  * **Conjugate** to (\phi_i^*=(R^*,t^*)) via
    (\phi_i^* = \Pi^{out}_* \circ \Pi^{out}_i{}^{-1} \circ \phi_i \circ \Pi^{in}*i \circ \Pi^{in}**{}^{-1}).
    Implement with the fixed composition/inverse formulas above; extract `pid*` and `(dy*,dx*)`.
  * **Forward map** each color plane of `X_star` through (\phi_i^*) and recolor:

    * For each (c\in \mathcal C):

      * Let (c') = `sigma_i.get(c, c)` (identity for untouched colors; σ is partial).
      * Compute `P = pose_plane(planes_in_star[c], pid*, H_in*, W_in*)` and then `T = shift_plane(P, dy*, dx*, R_out, C_out)` (zero-fill).
      * **Restrict to this piece’s target bbox** by forming a bbox mask (B^**{tgt}) (see next bullet) and set
        ( A_i[c'] \gets A_i[c'] \ &\  ( \neg B^**{tgt} ; \lor ; T )).
        (Equivalently: within the bbox, we require the color (c') wherever `T` has a 1; outside the bbox we leave `A_i` as is.)
    * **Scope update**: ( S_i \gets S_i \ \lor\ B^*_{tgt}).
  * **How to compute the target bbox (B^*_{tgt}):**
    Start from the **source** bbox of the piece in (\Pi^{in}*i): `bbox_src=(rmin,cmin,rmax,cmax)`.
    Apply the **pose** (R^*) to this bbox to get a posed bbox in (\Pi^{in}**) (use the same `_compute_posed_bbox` logic as in WO-06), then **shift** by ((dy^*,dx^*)) and **clip** to ([0..R_{\text{out}})\times[0..C_{\text{out}})). Convert to a per-row bitmask window `B*_tgt_rows` and OR it into `S_i`.

* **Per-training normalization (admit-all ⇒ silent):**
  After all pieces, compute `sum_bits[r] = Σ_{c∈C} ((A_i[c][r]) as bitwise OR over all colors?)`. For each row, find pixels where **every** color bit is 1 (i.e., the intersection did not constrain that pixel at all):
  ( U_r = \bigwedge_{c\in \mathcal C} A_i[c][r] ).
  Set `S_i[r] &= ~U_r`. (Pixels where `U_r` is 1 are **silent** even if a bbox covered them; this realizes “admit-all ⇒ scope=0”.)

> Intuition: We only claim witness scope where we actually asserted a **proper** color subset. Else the training contributes nothing at that pixel.

### 2) Global combine across trainings → ((A^{\text{wit}}, S^{\text{wit}}))

* **Scope union:** ( S^{\text{wit}} = \bigvee_i S_i).
* **Admits intersection with scope gating:** For each color (c\in\mathcal C), initialize (A^{\text{wit}}[c] = \mathbf{1}^{R_{\text{out}}\times C_{\text{out}}}). For each training (i):

  * For each row, compute masked plane: (M_{i,c}[r] = A_i[c][r] \ \lor\ \neg S_i[r]). (Outside the training’s scope we treat this training as admitting **all** colors.)
  * ( A^{\text{wit}}[c] \gets A^{\text{wit}}[c] \ &\ M_{i,c}).

That yields the **single** witness emitter ((A^{\text{wit}},S^{\text{wit}})) for the propagation loop.

---

## Invariants & failure behavior

* **No minted bits**: within (S^{\text{wit}}), colors are admitted only where a forward-mapped test bit exists under some conjugated piece; otherwise admission stays at 1 only because **no training** constrained that pixel.
* **Silent trainings**: if a training’s witness is `silent=True`, its (S_i=0) and its (A_i) behave as admit-all; thus it does not affect the global intersection.
* **Determinism**: D4 order, frame composition, bbox → pose → shift order, and color order are **frozen**; repeated runs produce identical ((A^{\text{wit}},S^{\text{wit}})).
* **Clipping**: All shifts/boxes are clipped to ([0..R_{\text{out}})\times[0..C_{\text{out}})) with zero-fill; negative offsets are legal.
* **Integer-only**: All transforms are integer D4 + integer shifts; no floats, no heuristics.

---

## Receipts (first-class; additive, stable)

Section: `"witness_emit"` (single section per task).

**Required:**

* `inputs`: `{ "R_out": R_out, "C_out": C_out, "num_trainings": N, "num_pieces_total": Σ_i |pieces_i| }`
* `scopes`: `{ "per_training_scope_bits": [ popcount(S_i) ... ], "scope_bits": popcount(S_wit) }`
* `admits`: `{ "A_wit_hash": blake3( serialize_planes(A_wit, R_out, C_out, colors_order) ) }`
* `families`: `{ "combined_from_trainings": [i for i with silent==false] }`
* `section_hash`: BLAKE3 over canonical JSON (WO-00)

**Optional (nice audit, add-only):**

* `per_training_piece_counts`: `[len(pieces_i) ...]`
* `normalized_silent_pixels`: popcount of (\bigvee_i U) removed by admit-all normalization.

---

## Edge cases (fully specified)

* **No trainings**: return (S^{\text{wit}}=0) and (A^{\text{wit}}[c]=\mathbf{1}) (i.e., emitter imposes no constraint); receipts should mark `num_trainings=0`.
* **All trainings silent**: same effect as above (no constraint); scope_bits=0; A_wit_hash still computed from all-ones planes + colors_order header.
* **Empty color universe beyond 0**: allowed; `colors_order` always contains 0; (A^{\text{wit}}[0]=\mathbf{1}) and others empty dict entries omitted.

---

## What’s explicitly out of scope here

* Any “output transport” for unanimity or period lattice (that’s T2/T3 emitters).
* Any CSP/morph/ICL logic (other WOs).
* Any mid-pipeline selection/painting (selection belongs to WO-13; propagation to WO-11).

---

## Developer checklist (Implementer)

* Implement frame **compose/inverse** once; unit-test that ( \Pi\circ \Pi^{-1} = I ).
* Build `planes_in_star` by applying `apply_pose_anchor` on `X_star` to (\Pi^{in}_*).
* For each training:

  * Skip or admit-all if `silent`.
  * For each piece: compute (\phi_i^*) by composing frames; pose & shift `planes_in_star[c]`; recolor via `σ_i` (identity for others); update (A_i) only **inside** the piece bbox-derived (B^*_{tgt}); OR that bbox into `S_i`.
  * After pieces: compute per-pixel all-colors-admitted mask (U) and clear those bits from `S_i`.
* Intersect (A_i) across trainings with scope gating, OR the scopes for (S^{\text{wit}}).
* Emit receipts as above.

---

## Reviewer quick-verification (real ARC; 1–2 lines)

* Single-training, single-piece toy: verify (S^{\text{wit}}) equals the conjugated target bbox and (A^{\text{wit}}_{c'}) equals the forward-mapped (B_c(X^*)) inside that scope (others all ones); `A_wit_hash` stable across runs.
* Multi-training: make one training `silent=True`; confirm `scope_bits` and `A_wit_hash` are unchanged by toggling that training, proving “silent ⇒ no constraint”.

---

This WO makes witness emission a **deterministic function of bits and frames**: conjugate once with frozen affine algebra; forward-map test planes with pure D4+shift; gate by exact bboxes; normalize away admit-alls; and intersect across trainings with a single, verifiable receipt.
