WO-00 you asked for. It is 100% grounded in the v1.4 spec + v1.5 addendum; pure CS primitives; no “engines.” It locks formats, orders, and failure modes so Claude can’t improvise.

# WO-00 — Param Registry & Receipts Core (foundation)

## Purpose

Provide a **single, deterministic substrate** for hashing, byte serialization, and parameter freezing. Every later WO depends on this for receipts and for the frozen constants (pose order, AC-3 order, etc.).

## Underspec risks (closed here)

* Byte layout of planes/grids: **fixed** below.
* Color ordering in receipts: **fixed** to ascending integer.
* JSON key order, time, randomness: **forbidden**; serializer must be stable.
* Hash function & input stream framing: **fixed** to BLAKE3 over **big-endian row-major** bytes, with explicit frame tags.
* Param registry contents and versioning: **fixed** list, version pinned to `"1.5"`.

---

## Interfaces (pure functions, no I/O, no wall clock)

### 1) Param registry

```python
def param_registry() -> dict:
    """
    Returns a frozen mapping of all global constants used by the solver.
    Keys and values must be JSON-serializable primitives or lists/tuples of them.
    """
```

**Required keys and values:**

* `spec_version`: `"1.5"`
* `endianness`: `"BE"`  (big-endian bit packing within bytes)
* `pose_order`: `["I","R90","R180","R270","FX","FXR90","FXR180","FXR270"]`
* `ac3_neighbor`: `"4"`  (4-neighbor)
* `ac3_queue_order`: `"row-major-pq-fifo"`
* `engine_priority`: `["T3","T5","T4","T6","T7","T8","T9","T10","T11"]`
* `bottom_color`: `0`
* `period_phase_origin`: `(0,0)`
* `strict_downscale`: `True`  (no majority; constant blocks only)
* `hash_algo`: `"BLAKE3"`
* `color_ordering`: `"ascending-int"`
* `byte_frame_tags`: `{"GRID":"GRD1","PLANES":"PLN1"}`  (ASCII tags; see hashing)

No other keys allowed.

### 2) Stable color universe packing

```python
def order_colors(C: set[int]) -> list[int]:
    """Return colors sorted ascending; 0 must be present and is included."""
```

### 3) Grid serialization to bytes

```python
def serialize_grid_be_row_major(G: list[list[int]], H: int, W: int, colors_order: list[int]) -> bytes:
    """
    Encode the grid as a stream for hashing.

    Format (exact):
    - 4 ASCII bytes tag: b"GRD1"
    - 2 bytes H (uint16, big-endian), 2 bytes W (uint16, big-endian)
    - 1 byte K (#colors), K bytes the color ids (uint8 each, ascending)
    - Payload: for each row r in 0..H-1, for each color in colors_order:
        emit  ceil(W/8) bytes mask:
          bit 7 -> column 0, bit 6 -> column 1, ..., bit 0 -> column 7,
          then next byte continues with column 8 at bit 7, etc.
        A bit is 1 iff G[r][c]==that color.
    - No timestamps, no padding beyond the per-row ceil(W/8) rule.
    """
```

**Notes:** This packs per-row, **per-color** masks one after another, guaranteeing stable framing and making plane reconstruction trivial.

### 4) Plane bundle serialization to bytes

```python
def serialize_planes_be_row_major(planes: dict[int, list[int]], H: int, W: int, colors_order: list[int]) -> bytes:
    """
    Encode per-color planes as row-packed masks.

    Format:
    - 4 ASCII bytes tag: b"PLN1"
    - 2 bytes H, 2 bytes W (big-endian)
    - 1 byte K, then K bytes color ids (ascending)
    - Payload: for each color in colors_order, for each row r, emit ceil(W/8) bytes
      with the same bit mapping (bit 7 -> col 0 ... bit 0 -> col 7).
    """
```

**Plane row storage:** each row is an **unsigned integer mask** in later modules; here it is emitted as bytes using the same bit mapping.

### 5) Hashing

```python
def blake3_hash(data: bytes) -> str:
    """Return hex-encoded BLAKE3 digest of the byte stream."""
```

* Must use a vendored BLAKE3 or a deterministic equivalent. No seeding. No streaming randomness.
* All receipts hash fields must be **exactly** the hex digest from this function.

### 6) Section receipts

```python
class Receipts:
    def __init__(self, section: str):
        """
        section: ASCII identifier for the logical unit (e.g., "WO-06-witness").
        Initializes an empty, ordered dict.
        """
    def put(self, key: str, value) -> None:
        """
        Insert key/value; keys must be unique. Values must be JSON-serializable
        and must not include non-deterministic fields (timestamps, memory ids).
        """
    def digest(self) -> dict:
        """
        Returns a dict:
          {
            "section": section,
            "spec_version": "1.5",
            "param_registry_hash": blake3_hash(json_dump(param_registry(), stable=True)),
            "payload": <ordered key/value pairs>,
            "section_hash": blake3_hash(json_dump(self, stable=True))
          }
        Where json_dump(..., stable=True) means:
          - UTF-8
          - Sorted keys
          - No whitespace variability
          - Deterministic float formatting is irrelevant (floats are forbidden)
        """
```

**Forbidden in receipts payload:** floats, time, random, object reprs; only ints/bools/strings/lists/tuples/dicts.

### 7) Double-run equivalence helper

```python
def assert_double_run_equal(build_section_callable) -> None:
    """
    Calls build_section_callable() twice; each call must produce the same 'section_hash'.
    If they differ, raise DeterminismError with fields ('first_differing_key', 'a', 'b').
    """
```

---

## Invariants (must hold)

* **No timestamps** or environment leakage; same inputs → same bytes → same hash.
* **Colors order** is ascending integers, always includes 0, used consistently across all serializers.
* **Bit mapping** is fixed: row-major; within each byte, **bit 7 ↔ col 0**, …, **bit 0 ↔ col 7**.
* **Spec version** and full `param_registry()` snapshot are hashed into every section receipt via `param_registry_hash`.
* **Non-strict modes** (e.g., majority downscale) do not exist at WO-00; this foundation is **strict** only.

---

## Failure modes

* `DeterminismError`: double-run mismatch.
* `SerializationError`: H/W mismatch, color not in `colors_order`, or non-binary mask overflow.
* `RegistryError`: missing required key or unexpected key in `param_registry()`.

---

## Edge cases

* **Empty grid (H=0 or W=0):** allowed; payload has zero rows; hashes remain well-defined.
* **All-zero grid:** permitted; pose/anchor elsewhere will note all_zero; here we just serialize masks.
* **Large W not multiple of 8:** last byte padded on the **right** (least significant bits) with zeros.

---

## What’s strictly **out of scope** for WO-00

* Any problem-specific logic (witness, lattice, AC-3, etc.).
* Any use of majority heuristics, RNG, or wall-clock.
* Any I/O beyond returning Python objects/bytes.

---

## Developer checklist (Implementer)

* Implement exactly the interfaces above; no helpers beyond this module.
* **No optional arguments**; signatures must match.
* Use only standard Python and the vendored BLAKE3; do not import datetime, random, numpy, or OS env.
* Ensure `serialize_grid_be_row_major` and `serialize_planes_be_row_major` produce **identical** bytes if fed equivalent content via either API.
* Add inline docstrings specifying the bit mapping and color ordering.

---

## Reviewer quick-tests (real ARC tasks; 1–2 lines each)

* Run the same training grid twice through `serialize_grid_be_row_major` → **identical** `blake3_hash`. Flip **one pixel** → hash must change.
* Build `param_registry_hash`; change `pose_order` locally in a copy → receipts’ `param_registry_hash` must change, proving registry binding.

---

This WO-00 is the bedrock. It pins bytes, hashes, orders, and registry so every higher WO’s receipts are comparable and deterministic.
