WO-09 you asked for‚Äîfrozen to v1.6 with a **single working canvas**, exact integer KMP, and receipts-first. It uses only core CS (bit-planes, period detection, exact equality), no heuristics.

# WO-09 ‚Äî Lattice Emitter (exact periodic admits)

## Purpose

From the **training outputs**, normalized and transported to the **working canvas** ((R_{out},C_{out})) in (\Pi_{out}^*) (via **WO-08**), detect a **global 2D period** and emit **residue-class admits** at pixels where **all included trainings** agree on the color of that residue. Where there is any disagreement or no period, the layer is **silent**.

> No LCM. All work is on the working canvas in (\Pi_{out}^*).

---

## Inputs (frozen)

* `A_out_list`: per-training dicts `color -> plane` returned by `emit_output_transport` (WO-08). Each is a **singleton** layer on ((R_{out},C_{out})).
* `S_out_list`: per-training scope masks on ((R_{out},C_{out})).
* `colors_order`: ascending int list (includes 0).
* `R_out, C_out`: working canvas shape.

> Train IDs with `S_out_i` all zeros are *silent* and ignored.

---

## Interface (pure; no I/O; receipts-first)

```python
from typing import Dict, List, Tuple, Optional, TypedDict

class LatticeReceipt(TypedDict):
    included_train_ids: List[int]
    p_r: Optional[int]       # proper minimal period ‚â•2 if present, else None
    p_c: Optional[int]
    agreeing_classes: List[Tuple[int,int]]     # residue pairs (i,j) on which all trainings agree
    disagreeing_classes: List[Tuple[int,int]]  # residue pairs where at least one training disagrees or no coverage
    residue_scope_bits: int                    # popcount of S_lat
    A_lat_hash: str
    S_lat_hash: str

def emit_lattice(
    A_out_list: List[Dict[int, List[int]]],
    S_out_list: List[List[int]],
    colors_order: List[int],
    R_out: int,
    C_out: int
) -> Tuple[Dict[int, List[int]], List[int], LatticeReceipt]:
    """
    Returns:
      A_lat : dict color->H_out row-masks (admit color on agreeing residue classes)
      S_lat : H_out-length scope mask (1 on agreeing residue classes)
      receipt : LatticeReceipt
    """
```

---

## Exact algorithm

### 0) Reconstruct per-training **color grids** on the working canvas

* For each included training (i): build `Y_i[r][c]` by reading its singleton planes:

  ```python
  Y_i = [[0]*C_out for _ in range(R_out)]
  for r in range(R_out):
      row = S_out_i[r]
      if row == 0: continue
      for c in range(C_out):
          bit = 1<<c
          if not (row & bit): continue
          # find the unique color
          u = None
          for col in colors_order:
              if A_out_i[col][r] & bit:
                  u = col; break
          if u is None:
              # Defensive: silent where scope says defined but no plane set
              continue
          Y_i[r][c] = u
  ```

This guarantees a single integer grid per training on ((R_{out},C_{out})).

### 1) Compute global 2D period on the working canvas (KMP; proper ‚â• 2)

* For each included training (i), run **WO-02** period detection on `Y_i` **as a K-tuple alphabet** (colors as integers; per the WO-02 ‚Äúsymbol tuple‚Äù logic, equality only):

  * Compute row/col proper minimal periods `p_r_i, p_c_i` (‚â•2 or None).
* **Aggregate** across trainings (included only):

  * If any training has a **different** proper period on rows (and both are non-None), set `p_r=None` (no global row period). Else if **all** are None ‚Üí `p_r=None`; else `p_r` is the common period integer.
  * Same for columns ‚Üí `p_c`.
* If **both** `p_r` and `p_c` are `None` ‚Üí **silent** layer: `S_lat=0`, `A_lat` all zeros; receipts record `p_r=None`, `p_c=None`.

### 2) Emit residue-class admits only where **all** included trainings agree

* If `p_r` is not None, row residues are (i \in [0..p_r-1]); else treat rows as **no partition** (single residue (i=0) covering all rows).
* If `p_c` is not None, col residues are (j \in [0..p_c-1]); else treat cols as **no partition** (single residue (j=0) covering all cols).
* For each residue pair ((i,j)):

  * Build the **residue mask** (R_{i,j}) (bit 1 at ((r,c)) iff ((r \bmod p_r=i)) and ((c \bmod p_c=j)); if `p_r=None`, use all rows; if `p_c=None`, use all cols).
  * For included trainings (i\in\mathcal I), collect their **colors on that residue**:
    `U = { Y_t[r][c] : t‚ààùïÄ, for all (r,c) with R_{i,j}[r] having bit c AND S_out_t[r] having bit c }`.
    If **any** included training is **silent** at some ((r,c)) in the residue (`S_out_t` bit 0) ‚Üí **Exclude that pixel** from the vote (we only compare where all trainings define a color).
  * If **after masking** there exists at least one pixel in the residue where **all** included trainings define a color and **all those colors are equal to the same `u`**, and **no pixel in the residue** contradicts that `u` ‚Üí **agreeing class**:

    * Set `S_lat` bits on **all pixels of that residue** where **all trainings define a color**.
    * Set `A_lat[u][p]=1` on those pixels; other colors 0 there.
    * Append `(i,j)` to `agreeing_classes`.
  * Else append `(i,j)` to `disagreeing_classes` and do **not** set `S_lat` bits for that residue (silent).

> We require residue-level unanimity **where defined**; we do not extrapolate through silent pixels.

### 3) No admit-all outside scope

* `S_lat` is 1 exactly on pixels of agreeing residues where **all trainings** define a color; elsewhere `S_lat` is 0 and all planes `A_lat[*]` are zero. The later intersection logic will treat `S=0` as admit-all (by gate), so **do not** fill ‚Äúall colors‚Äù here.

---

## Receipts

* `included_train_ids`
* `p_r`, `p_c` (proper global periods or None)
* `agreeing_classes` (list of residue pairs)
* `disagreeing_classes`
* `residue_scope_bits = popcount(S_lat)`
* `A_lat_hash = blake3(hash of planes in BE row-major over colors_order)`
* `S_lat_hash = blake3(hash of S_lat)`

All in a sealed `LatticeReceipt` and a section hash. Deterministic across runs.

---

## Invariants (must hold)

* **Integer-only, exact equality**: KMP on rows/cols, color-equality only; proper periods p‚â•2; no phase search (phase=(0,0)).
* **Trainings-only**: computed solely from transported training outputs (on the working canvas).
* **No minted bits**: only admit singletons on agreeing residue classes; otherwise silent.
* **Determinism**: frozen orders (colors_order for planes, residue iteration row-major over ((i,j))); double-run hashes must match.

---

## Edge cases

* If either axis has **no global period** (`p_r=None` or `p_c=None`), residues collapse to one class on that axis. The algorithm still works and may emit a 1D lattice if the other axis agrees.
* If **no trainings included** (all silent from WO-08), the lattice is **silent** (S_lat=0).
* If **some pixels** in a residue are undefined in one training, we only consider pixels where **all** trainings define a color; disagreement anywhere ‚Üí residue is disagreeing.

---

## What‚Äôs explicitly out of scope

* Any value synthesis or palette logic (colors are integers).
* Any domain propagation (AC-3/LFP).
* EngineWinner selection (later milestones).

---

## Developer checklist

* Reconstruct per-training grids from `A_out_i`/`S_out_i` exactly.
* Run WO-02 KMP **on those grids** to get proper periods; aggregate to global.
* Emit residues only where **all included trainings agree**; no ‚Äúadmit-all‚Äù planes.
* Emit receipts per above; assert double-run equality.

---

## Reviewer quick-verification (real ARC; 1‚Äì2 lines)

* On a clean periodic task (e.g., checkerboard), verify `p_r,p_c` match expected periods and `agreeing_classes` cover the canvas; `selection` with lattice-only solves GT.
* On a task with mixed residues, verify those residues land in `disagreeing_classes` and `S_lat` is zero there (silent), not filled with admits.
