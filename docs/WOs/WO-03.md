
WO-03 you asked for. It is strictly grounded in the math spec + addendum v1.5 (Frames §5; Addendum B.1), uses only core CS, and makes receipts first-class. No heuristics, no ambiguity.

# WO-03 — Frame Canonicalizer (D4 lex-min + anchor)

## Purpose

Freeze the **presentation frame** for any grid (G) so every later step (witness learning, output transport, unanimity) sees a **unique pose and anchor**. Colors never change; only **positions** change by a D4 pose and an integer translation that moves the first nonzero to the origin.

---

## Interfaces (pure; exact signatures; no optional args)

### 1) Canonicalize a **color grid**

```python
from typing import Tuple, List

def canonicalize(G: List[List[int]]) -> Tuple[str, Tuple[int,int], List[List[int]]]:
    """
    Return (pid, anchor_rc, G_canon) where:
      pid ∈ {"I","R90","R180","R270","FX","FXR90","FXR180","FXR270"}
      anchor_rc = (ar, ac) is the translation that moves the first nonzero to (0,0)
      G_canon is the posed+anchored grid (same colors; no palette)

    Frozen algorithm:
      1) Pose enumeration (rectangular-aware):
         For each pid in frozen order O = [I, R90, R180, R270, FX, FXR90, FXR180, FXR270]:
           - Apply pose to G to get G_pose with shape (H', W') (90/270 swap H,W).
      2) Lex ordering by byte stream:
         - Serialize each G_pose using WO-00 serialize_grid_be_row_major (tag "GRD1"),
           with color universe = ascending unique colors in G (0 allowed if present).
         - Choose the lexicographically smallest byte stream; ties broken by pid order O.
         - Let pid* be the chosen pid and G_pose* its grid.
      3) Anchor:
         - Find the first nonzero cell of G_pose* by row-major scan.
           If none: all_zero case (see Edge cases).
           Else set anchor_rc = (ar, ac) = (row, col) of that cell, and translate G_pose*
           by subtracting (ar, ac) on coordinates (i.e., shift up by ar and left by ac),
           discarding negative indices (everything moves so that that cell lands at (0,0)).
         - Result is G_canon.
    """
```

### 2) Apply pose+anchor to **planes** (multi-color)

```python
from typing import Dict

def apply_pose_anchor(
    planes: Dict[int, List[int]],  # color -> row masks (bit j == col j)
    pid: str,
    anchor: Tuple[int,int],
    H: int, W: int
) -> Tuple[Dict[int, List[int]], int, int]:
    """
    Apply the same frame (pid, anchor) to packed bit-planes:
      - First pose every color plane by kernel.pose_plane (WO-01) to (H',W')
      - Then translate by (-anchor.r, -anchor.c) with kernel.shift_plane (zero-fill)
    Return (planes', H', W').

    Colors are untouched; only coordinates change.
    """
```

---

## Exact definitions & frozen choices

### D4 poses (rectangular-aware)

* Use WO-01 `pose_plane` mapping (pure pull remap). Non-square inputs swap H,W for 90/270 poses (and their FX variants). **No wrap.** **No interpolation.**

### Lex ordering of poses

* Serialization for comparison is **WO-00 serialize_grid_be_row_major** with tag `"GRD1"`, **big-endian row-major**, and **colors listed ascending** (Addendum A.1 color ordering).
* Choose the **lexicographically smallest byte stream**. If **tie**, break by frozen pid order:
  `O = [ "I","R90","R180","R270","FX","FXR90","FXR180","FXR270" ]`.

### Anchor (translation)

* After choosing pid*, on **that posed grid**:

  * If any nonzero exists, set `anchor_rc = (ar,ac)` to the **first** such cell in row-major order (top-to-bottom, left-to-right).
  * Apply integer translation **up by ar** and **left by ac** (equivalently, shift by `(-ar, -ac)`) so that cell becomes (0,0).
  * Translation is **zero-fill** (bits shifted off negative indices are discarded). **No wrap.**
* If no nonzero exists: see **Edge cases**.

### Coordinate system

* Rows increase downward, columns increase to the right. Bit j encodes column j (WO-01 convention).

### Colors & palette

* **Never recolor.** Frames act on **positions only**. Colors remain the original ARC integers.

---

## Invariants (must hold)

* **Determinism:** same input grid → same `(pid, anchor, G_canon)`; double-run identical receipts.
* **Idempotence:** applying `apply_pose_anchor` with `(pid,anchor)` to G must produce a grid that, when fed back to `canonicalize`, yields the same `(pid,anchor)` and identical bytes.
* **Pose inverses:** for planes, `pose_plane(..., pid)` then `pose_plane(..., inv(pid))` returns the original plane bit-for-bit and restores shape.
* **No palette logic, no heuristics:** only D4 + integer shift.
* **No minted bits:** canonicalization never creates nonzero entries; it only relocates existing ones.

---

## Edge cases (fully specified)

* **All-zero grid:** return `pid="I"`, `anchor=(0,0)`, `G_canon` = the original grid (no shift). Receipt flag `all_zero=true`.
* **Single nonzero:** anchor becomes that pixel; `G_canon` has a single nonzero at (0,0).
* **H=0 or W=0:** treat as all-zero; identity pose, anchor=(0,0).
* **Tie among multiple symmetric poses:** broken strictly by the frozen pid order O, logged via `pose_tie_count`.

---

## Failure modes

* **ValueError** if G has ragged rows or negative colors (structural), or if `pid` not in O for `apply_pose_anchor`, or if plane row counts/bounds mismatch `H,W`.
* No partial result; functions are pure.

---

## Receipts (first-class; algebraic)

Emit a sealed section receipt (via WO-00) **per grid** canonicalized:

* `frame.inputs`: `{H, W, colors_order (ascending), nonzero_count}`
* `frame.pose`: `{pose_id, pose_tie_count}`

  * `pose_tie_count` = number of poses sharing the minimum byte stream (≥1)
* `frame.anchor`: `{r: ar, c: ac}`, `all_zero: true|false`
* `frame.bytes.hash_before`: blake3 of the winning pose’s byte stream (pre-anchor)
* `frame.bytes.hash_after`: blake3 of the final `G_canon` byte stream (post-anchor)
* `section_hash`: blake3 over the canonical JSON
* **Determinism proof hook:** include a boolean `idempotent=true` when re-canonicalizing `G_canon` yields identical receipt fields.

For `apply_pose_anchor` on planes, log a parallel receipt:

* `apply.pose_id`, `apply.anchor`, `apply.shape_before=(H,W)`, `apply.shape_after=(H',W')`, and a cross-check hash comparing `serialize_planes(G_canon)` to `serialize_grid(G_canon)` (they must match).

---

## What’s explicitly **out of scope**

* Any size inference, object detection, or pattern learning (those belong to later modules).
* Any resampling, scaling, or shear (strictly D4 + translation).
* Any time-based or RNG behavior.

---

## Developer checklist (Implementer)

* Implement pose application using **WO-01 `pose_plane`** for planes; for color grids, either map via planes or a direct remap—results must match WO-00 serializers.
* Implement lex compare using **WO-00 `serialize_grid_be_row_major`** only; do **not** invent another comparator.
* Enforce integer translation by **kernel.shift_plane** semantics (zero-fill, no wrap).
* Add an `idempotence_check(G)` helper that re-canonicalizes `G_canon` and asserts equality.

---

## Reviewer quick-verification on **real ARC tasks** (not unit tests)

* Take a training grid with clear symmetries; re-run canonicalize twice: `pose_id` and `anchor` must be identical; `pose_tie_count` stable; idempotence receipt `true`.
* Apply `apply_pose_anchor` to planes, then serialize planes vs grid for the canonical result: the two hashes must **match bit-for-bit**.
