M4 milestone you asked for—wired to v1.6 (single working canvas, no LCM) and our finished WOs **10 (Forbids + AC-3)** and **11 (LFP Propagator)**. It uses only core CS (bitsets, fixed 4-neighbor graph, textbook AC-3), is fully deterministic, and receipts-first. No heuristics.

# Milestone M4 — “True LFP”

**Prereqs:** WO-07 (witness emit), WO-08 (output transport + unanimity), WO-10 (forbids + AC-3), WO-11 (LFP).
**Runner:** `src/arcbit/runner.py`

---

## Runner contract (frozen) — M4 delta

```python
def solve(task_json) -> (Y_out, receipts_bundle_or_unsat):
    # M0: bedrock (color_universe, pack/unpack, frames, receipts)
    # M1: working canvas (WO-04a) -> (R_out, C_out)
    # M2: output path -> (A_out_i, S_out_i), (A_uni, S_uni)
    # M3: witness path -> (A_wit, S_wit)

    # M4: True LFP (WO-10 + WO-11)
    # 0) Build forbids once from trainings (optional)
    E_graph, M_matrix, forbids_receipt = learn_forbids(Y_train_on_canvas, included_ids, colors_order)

    # 1) Assemble emitters in FROZEN family order (present ones only)
    emitters = [
      ("T1_witness",  A_wit, S_wit),
      ("T2_unity",    A_uni, S_uni),
      # If you already have lattice or other engines at this time, insert here:
      # ("T3_lattice",  A_lat, S_lat),
      # ("T4_kron",     A_kron, S_kron), ...
    ]

    # 2) Initialize domains D0 to "all colors" (bitmask of ones) everywhere
    D0 = {(r,c): ((1 << len(colors_order)) - 1) for r in range(R_out) for c in range(C_out)}

    # 3) Run fixed-point propagation (WO-11): admit-∧ pass (T1..T12) then AC-3; repeat
    D_star, lfp_stats = lfp_propagate(
        D0, emitters_list=emitters, forbids=(E_graph, M_matrix), colors_order=colors_order
    )
    # Or: status, stats = lfp_propagate(...), where status=="UNSAT"/"FIXED_POINT_NOT_REACHED"

    # 4) If UNSAT or cap-hit → fail-closed (return the status + stats receipts)
    # 5) Selection (no EngineWinner yet): witness → unanimity → bottom
    Y_out, sel_receipts = select_witness_first(A_wit, S_wit, A_uni, S_uni, colors_order, R_out, C_out)

    # 6) Seal receipts: forbids, LFP stats, selection; return
    return Y_out, receipts_bundle
```

**Notes**

* **No LCM** anywhere (v1.6). All coordinates and planes are on the working canvas ((R_{out}, C_{out})).
* **EngineWinner** not used at M4 (that’s M5).
* Emitters are **scope-gated**: their admits intersect only where `S==1`.
* AC-3 uses WO-10’s directed 4-neighbor graph in **row-major** order, **FIFO** queue.

---

## Frozen details (remove ambiguity)

### Domains & colors (bit-exact)

* `colors_order` is the frozen ascending integer list (includes 0).
* A domain at pixel ((r,c)) is a **bitmask** over `colors_order`.
* Initialization at M4 uses **all ones** (you may integrate earlier stages’ admits by starting D0 with an initial T-pass, but the default is all ones).

### Emitters order (family order T1..T12)

* Apply **only** the families you have **in this exact order**:
  `T1_witness → T2_unity → T3_lattice → T4_kron → T5_conv → T6_morph → T7_logic → T8_param → (T9=n/a) → T10 forbids handled by AC-3 → T11_csp → T12_strata`.
* Absent families are simply **skipped**. Never change the order.

### LFP loop (WO-11)

* Pass = **admit-intersect** (scope-gated) then **AC-3** (if forbids available).
* Early exit if any domain becomes **empty** → **UNSAT** (fail-closed).
* Hard cap guard (`MAX_PROPAGATION_ITERATIONS=1000`) → **FIXED_POINT_NOT_REACHED** (fail-closed).
* Determinism: each pass does **exactly** T-order admits, then AC-3 with WO-10 frozen queue.

### Forbids (WO-10)

* `learn_forbids(...)` may return an **all-zero matrix** (permissive) when nothing is provable; that’s fine—AC-3 prunes nothing.
* `E_graph` is the directed 4-neighbor edge list in row-major; receipts must include `edges_count`.

### Selection at M4

* Precedence remains **witness → unanimity → bottom** (no EngineWinner yet).
* Pick **min color** from `A_wit` at scope pixels; else singleton from unanimity; else 0.
* Containment is trivially true with all-ones D0, but we keep the field for M5+.

---

## Receipts (first-class; additive; stable)

Add two sections (names & keys frozen):

1. **`forbids`** (WO-10):

   * `forbid_symmetric: true|false`, `matrix_hash`, `edges_count`.

2. **`lfp`** (WO-11):

   * `admit_passes`, `ac3_passes`,
   * `total_admit_prunes`, `total_ac3_prunes`,
   * `empties` (count of empty domains; >0 if UNSAT),
   * `domains_hash` (BLAKE3 of final per-pixel bitmasks),
   * `section_hash`.

The existing `selection` section (from M2/M3) remains with `precedence`, `counts`, `repaint_hash`.

Optional (add-only, helpful):

* `lfp.singleton_pixels`, `lfp.multi_pixels` (post-LFP counts) to track when you actually hit the “singleton implies match” state.

---

## Invariants & determinism

* **Monotone descent**: each step only clears bits from domains; loop stabilizes.
* **Frozen orders**: family order; AC-3 queue (row-major arcs, FIFO), neighbor order; color order.
* **Receipts must match** on double‐run (no RNG, no time, no sets with arbitrary iteration).
* **Fail-closed**: UNSAT or cap-hit never returns a guessed grid—only receipts with status and stats.

---

## What to expect at M4 (and how to judge it)

* For most **M2/M3** tasks, final `Y_out` should **match** what you produced pre-LFP (witness/unanimity were already singletons at many pixels).
* LFP becomes critical where **multiple families overlap** or where **forbids** prune multi-valued pixels down to **singletons**—these are your first formal “singleton ⇒ must match” cases.
* If `lfp.empties > 0` → **UNSAT** is correct; the receipts show where domains turned empty.
* If `lfp.singleton_pixels == R_out*C_out` and `Y_out ≠ GT`, that’s a **real bug** (selection/conjugation/σ/transport); the receipts pinpoint which law set the bits.

---

## Developer checklist (Runner wiring)

* Build `Y_train_on_canvas` once (WO-08 reconstruct), pass to `learn_forbids`.
* Assemble `emitters` list (only available families) in **frozen order**.
* Initialize `D0` to **all ones** (or feed prior admits as a first pass—optional).
* Call `lfp_propagate` and handle status (`UNSAT`, `FIXED_POINT_NOT_REACHED`) fail-closed.
* Run **selection** (`witness → unanimity → bottom`) and seal receipts.

---

## Reviewer quick-verification (real ARC; 1–2 lines)

* On a toy where M2/M3 already solved it, verify M4 yields **identical Y_out** and `lfp.total_prunes == 0`.
* On a crafted contradiction (forbids disallow a witness singleton), verify `UNSAT` with `lfp.empties > 0` and stable `domains_hash` up to the UNSAT point.
