WO-02 you asked for. It is strictly grounded in the math spec + addendum v1.5 and sticks to core CS. No heuristics, no catalogs, no floats. Receipts are first-class.

# WO-02 â€” PERIOD (1D minimal period + 2D residues)

## Purpose

Provide **exact, integer** period detection primitives that higher layers (e.g., lattice emitter) can rely on. We compute minimal 1D periods with KMP-style prefix function and lift them to a **global 2D period** over multi-color planes. We also build residue-class masks with **phase fixed at (0,0)**.

---

## Interfaces (pure; no optional args; no I/O)

### 1) Minimal 1D period for a binary row (bits â†’ {0,1} string)

```python
def minimal_period_1d(mask_bits: int, W: int) -> int | None:
    """
    Return the minimal period p (2 <= p <= W) if the length-W bitstring
    of this row is an exact repetition with period p; else return None.
    Definition: Let s[j] = (mask_bits >> j) & 1 for j in 0..W-1.
    Compute prefix-function Ï€ over {0,1}; t = W - Ï€[W-1].
    If t < W and W % t == 0: return t; else None.
    """
```

**Notes (frozen):**

* Bit j corresponds to **column j** (same convention as WO-01).
* Rows of all zeros or all ones return `None` unless W has a proper period that exactly reconstructs; e.g., `0000` â†’ `p=2` and `p=1` both reconstruct, but we only return **proper** period `p>1`; algorithm correctly yields `p=2`.

### 2) Global 2D period for a **multi-color** plane bundle

```python
from typing import Dict, List, Tuple, Optional

def period_2d_planes(
    planes: Dict[int, List[int]],  # color -> row masks
    H: int, W: int,
    colors_order: List[int]
) -> Tuple[Optional[int], Optional[int], List[List[int]]]:
    """
    Compute the minimal positive 2D periods (p_r, p_c), each >= 2,
    for the *entire multi-color grid*, or (None, None, []) if no proper period exists.
    Also return residue-class masks (phase fixed at (0,0)) as a list of planes,
    ordered by residue (i,j) in row-major over residues:
      index = i * p_c + j, where i in [0..p_r-1], j in [0..p_c-1].
    Each residue mask is an H-length list[int] (row masks), 1 iff (r % p_r == i and c % p_c == j).
    """
```

**Exact definition (frozen):**

Let the grid be represented by per-color planes `planes[c][r]` with bit j set iff cell (r,j) is color c.

* **Column period p_c:**

  1. For each row `r`, build a **symbol sequence** over columns of length W:
     `sym_r[c] = tuple( (planes[color][r] >> c) & 1 for color in colors_order )`.
     This symbol is a K-bit tuple (K = |colors_order|).
  2. Compute the **minimal 1D period** `t_r` of sequence `sym_r[0..W-1]` using the **prefix function** over equality of K-tuples (generalized KMP; equality only, no hashing).

     * If the row is unconstraining (all K-tuples equal), `t_r` may be any divisor; keep the KMP result (possibly `None`).
  3. Let `S = { t_r | t_r is not None }`. If `S` is empty â‡’ **no constraint** along columns.
     Otherwise set preliminary `p_c = LCM(S)`.
  4. **Validation:** Check that for all rows r and all columns c where c+p_c < W, we have `sym_r[c] == sym_r[c+p_c]`. If this fails, then **no proper column period** exists â‡’ `p_c = None`.

* **Row period p_r:** symmetric to columns:

  1. For each column `c`, build symbol sequence over rows of length H:
     `sym_c[r] = tuple( ((planes[color][r] >> c) & 1) for color in colors_order )`.
  2. Compute minimal 1D period `t_c` (KMP) for each column; let `S' = { t_c | t_c not None }`.
     If `S'` empty â‡’ no row constraint; else `p_r = LCM(S')`.
  3. Validate: for all columns c and all rows r with r+p_r < H, check `sym_c[r] == sym_c[r+p_r]`. If fails â‡’ `p_r = None`.

* **Nontrivial 2D period:** We return `(p_r, p_c)` where each is either `None` or an integer â‰¥ 2. If both are `None`, residues list is `[]`. If one is `None` and the other not, return the found one (e.g., stripes), and residues will reflect only that dimension (the other dimensionâ€™s period is effectively H or W, but we **do not** invent a value; residues still computed using the found period, with phase at (0,0); see residue construction below).

* **Residue masks (phase = (0,0)):**

  * If both `p_r` and `p_c` are present: build `p_r * p_c` residue masks.
  * If only one is present (say `p_c`), set `p_r = 1` for residue construction purposes **internally** (not returned), and build `1 * p_c` masks. Similarly for only `p_r`.
  * If neither is present: residues `[]`.

---

## Underspecified risks (closed here)

* **Multi-color coherence:** We compute periods on **K-tuple symbols** (across all colors) so the period is global; no per-color contradictions.
* **Aggregation across rows/cols:** We use **LCM of per-row (or per-col) minimal periods**, then **validate** globally. This aligns with the math: any multiple of a rowâ€™s minimal period is also a period; the LCM is the smallest period satisfying all rows (ditto columns).
* **Phase choice:** Fixed at **(0,0)** (top-left origin), consistent with v1.5.
* **Bounds:** We search via KMP across the full length (no 10-cap); exact and finite (H,W â‰¤ 30).
* **Trivial vs proper period:** Only return `p â‰¥ 2` as a â€œproperâ€ period; otherwise `None`. This prevents declaring â€œperiod 1.â€
* **Residue construction when only one axis is periodic:** We generate residue masks for the periodic axis only, without inventing a second axis period.

---

## Invariants (must hold)

* **Pure equality logic:** KMP over symbols uses only equality comparisons on K-tuples; no hashing, no floats.
* **Determinism:** Given identical `planes,H,W,colors_order`, results are identical. No randomness, no iteration-order dependence.
* **Validation after LCM:** The chosen `p_r`/`p_c` must pass exact equality checks across the full grid (not just per row/col summaries).
* **Phase fixed:** residues correspond to `(r % p_r, c % p_c)` with origin at (0,0).
* **No minted bits:** This module **never** produces colorsâ€”only **masks** and integers.

---

## Failure modes (explicit)

* `ValueError` if plane shapes mismatch `H` or row masks contain bits beyond `[0..W-1]`.
* Otherwise, absence of period is represented by `(None, None, [])`; **not** an exception.

---

## Receipts (first-class; algebraic)

Emit a sealed receipt (via WO-00) summarizing *what was proved*:

* `period.inputs`:

  * `H, W, K = len(colors_order)`
  * `colors_order` (ascending ints)
* `period.candidates`:

  * `row_periods_nontrivial`: list of all `t_r` (ignoring None)
  * `col_periods_nontrivial`: list of all `t_c` (ignoring None)
  * `p_r_lcm_pre`, `p_c_lcm_pre` (before validation, or null)
* `period.validation`:

  * `p_r_valid: true|false`, `p_c_valid: true|false`
  * `p_r` (final or null), `p_c` (final or null)
  * `phase: [0,0]`
* `period.residues`:

  * `count` (= 0 if both None; else `p_r*p_c` or `p_r` or `p_c`)
  * **(Optional but helpful)** first 2â€“3 residue masksâ€™ **row popcounts** to anchor regressions
* `section_hash` (BLAKE3 over the canonical JSON)

No RNG; the same planes produce the same receipt.

---

## Edge cases (fully specified)

* **All-zero grid:** Both dimensions unconstrained â‡’ `(None, None, [])`.
* **Vertical stripes:** Only `p_c` non-null; `p_r=None`. Residues are `1*p_c` masks (internally treat `p_r=1` for mask construction).
* **Horizontal stripes:** Only `p_r` non-null; symmetric handling.
* **Small sizes:** If `W<2`, then `p_c=None` (cannot have proper period); if `H<2`, then `p_r=None`.
* **Rows/cols with no constraint:** Rows or columns that are constant (all K-tuples equal) yield `t_r=None`/`t_c=None`; they **do not** constrain the LCM.

---

## Whatâ€™s explicitly **out of scope**

* Picking colors for residues (thatâ€™s the lattice emitterâ€™s job).
* Any â€œphase searchâ€: phase is frozen to (0,0).
* Any non-exact matching (no Hamming thresholds, no FFT).

---

## Developer checklist (Implementer)

* Implement `minimal_period_1d` exactly as KMP prefix-function over {0,1}.
* Implement `period_2d_planes` with **K-tuple symbols** and **LCM-then-validate** logic.
* Validate bit bounds on inputs; raise `ValueError` on violations.
* Produce a receipts dict with the exact keys above via WO-00; no timestamps, no floats.

---

## Reviewer quick-verification on **real ARC tasks** (not unit tests)

* Pick a periodic output (e.g., our tiling task): the returned `(p_r,p_c)` must be non-null and tiling the top-left `p_rÃ—p_c` motif should reconstruct the canvas bit-exact.
* Pick a non-periodic output: at least one of `(p_r,p_c)` must be `None`, and any attempt to tile with a non-null candidate must fail equality under your check.

# Patch
Hereâ€™s a tiny, receipts-first **Sub-WO** to patch WO-02. Itâ€™s fully aligned with v1.5 and our computing spec.

# Sub-WO-02a â€” PERIOD pâ‰¥2 Patch (strict proper periods)

## Purpose

Enforce **proper periods only** for 1D rows (p â‰¥ 2). Ensure receipts never report `1` in any period list. This removes the ambiguity the reviewer hit.

## Interfaces (unchanged)

* `minimal_period_1d(mask_bits: int, W: int) -> int | None`
* `period_2d_planes(planes, H, W, colors_order) -> (p_r|None, p_c|None, residue_masks)`

## Frozen changes (exact)

1. **Gate pâ‰¥2 in minimal_period_1d**

   * After computing `pi` and `t = W - pi[W-1]`, replace the return condition with:

   ```python
   if t >= 2 and t < W and (W % t == 0):
       return t
   return None
   ```

   * This is the *only* logic change in this function.

2. **Receipts filtering in period_2d_planes**

   * When building `row_periods_nontrivial` and `col_periods_nontrivial`, **exclude** `1`:

   ```python
   row_periods_nontrivial = [t for t in row_t_list if t is not None and t >= 2]
   col_periods_nontrivial = [t for t in col_t_list if t is not None and t >= 2]
   ```

   * LCM/validation uses these filtered lists (no 1s).

3. **Docstrings & examples**

   * Update examples to show solids return `None`:

     * `minimal_period_1d(0b111111, 6) â†’ None`
     * `minimal_period_1d(0b101010, 6) â†’ 2`

## Invariants (re-asserted)

* Proper periods only (p â‰¥ 2). Solids/constant rows â†’ `None`.
* Phase fixed at **(0,0)** (unchanged).
* Determinism: identical inputs produce identical `(p_r,p_c)` and residue masks.

## Receipts (add/check fields)

For the PERIOD section receipt (via WO-00):

* `period.inputs`: `{H,W,K,len(colors_order)}`
* `period.candidates`:

  * `row_periods_nontrivial` (no 1s)
  * `col_periods_nontrivial` (no 1s)
  * `p_r_lcm_pre`, `p_c_lcm_pre`
* `period.validation`: `p_r_valid`, `p_c_valid`, `p_r`, `p_c`, `phase:[0,0]`
* `period.residues`: `count`, and **optional** first two residue row-popcounts
* `section_hash`

## Failure modes (unchanged)

* `ValueError` on shape/bit bounds.
* Otherwise `(None,None,[])` denotes no proper period.

## Implementer checklist (tight)

* Edit `minimal_period_1d` to gate pâ‰¥2 as above; **no other changes**.
* Filter out `1` when collecting row/col t-values; keep receipts identical in shape.
* Update docstrings/examples to reflect proper-period rule.
* Run a quick local probe (no RNG): rows `"000000"`, `"111111"` â†’ `None`; `"101010"` (W=6) â†’ `2`; `"110110"` (W=6) â†’ `3`.

## Reviewer quick check (real ARC, 1â€“2 lines)

* On any **solid** training row, `minimal_period_1d` returns `None`, and receipts lists contain no `1`.
* On a **striped** output (e.g., 2-period tiling), `(p_r,p_c)` reflect the true divisors (â‰¥2) and reconstruct the canvas by residues bit-exact.

## Grounding in spec

* v1.5 â€œProper period onlyâ€ is explicit (WO-02 wording: â€œMinimal > 1 if non-trivial, else Noneâ€).
* Phase (0,0), equality-only KMP, and LCM-then-validate remain unchanged. No heuristics added.

Thatâ€™s itâ€”small, surgical, receipts-first, and eliminates the reviewerâ€™s failure without touching any other semantics.

====
Any other immediate changes? Update the runner to call WO-04a before any emitters; all emitters must take ( ð‘… ð‘œ ð‘¢ ð‘¡ , ð¶ ð‘œ ð‘¢ ð‘¡ ) (R out â€‹ ,C out â€‹ ) as their target shape. 
When you reach WO-08 and WO-09, incorporate the v1.6 Unanimity and Lattice changes (replicate/decimate inclusion + compute on working canvas). When you reach WO-12 (EngineWinner), compute training-scope on the working canvas as frozen.


---

## Changes to WO-15 (Finalize)

Under v1.6 there is **no post-solve downscale**. So:

* **WO-15 becomes a no-op pass-through** that can:

  * verify the produced (Y) matches ((R_{out},C_{out})) from WO-04a,
  * optionally run a **strict check** if the chosen hypothesis was H6/H7 and you want to re-verify stride constraints on the final output (optional receipt).
* Keep WO-15 file for structure, but its role is â€œfinal size sanity + receipts.â€

**WO-15 Interface (reduced)**

```python
def finalize_output(Y_canvas, R_out, C_out, size_fit) -> (Y_final, finalize_receipt)
# Validates Y_canvas.shape == (R_out, C_out); returns Y_final=Y_canvas
# Receipt logs size_winner echo and shape_check:true
```

**Reviewer quick-check**

* Finalize returns the same grid; receipt shows `shape_check:true` and echoes `size_winner`.

---

## Any other immediate changes?

* Update the **runner** to call WO-04a **before** any emitters; all emitters must take ((R_{out},C_{out})) as their target shape.
* When you reach WO-08 and WO-09, incorporate the v1.6 Unanimity and Lattice changes (replicate/decimate inclusion + compute on working canvas).
* When you reach WO-12 (EngineWinner), compute training-scope on the **working canvas** as frozen.

Weâ€™re on the same page: Iâ€™ll include receipts and reviewer checks when we expand each WO later.
