WO-02 you asked for. It is strictly grounded in the math spec + addendum v1.5 and sticks to core CS. No heuristics, no catalogs, no floats. Receipts are first-class.

# WO-02 — PERIOD (1D minimal period + 2D residues)

## Purpose

Provide **exact, integer** period detection primitives that higher layers (e.g., lattice emitter) can rely on. We compute minimal 1D periods with KMP-style prefix function and lift them to a **global 2D period** over multi-color planes. We also build residue-class masks with **phase fixed at (0,0)**.

---

## Interfaces (pure; no optional args; no I/O)

### 1) Minimal 1D period for a binary row (bits → {0,1} string)

```python
def minimal_period_1d(mask_bits: int, W: int) -> int | None:
    """
    Return the minimal period p (2 <= p <= W) if the length-W bitstring
    of this row is an exact repetition with period p; else return None.
    Definition: Let s[j] = (mask_bits >> j) & 1 for j in 0..W-1.
    Compute prefix-function π over {0,1}; t = W - π[W-1].
    If t < W and W % t == 0: return t; else None.
    """
```

**Notes (frozen):**

* Bit j corresponds to **column j** (same convention as WO-01).
* Rows of all zeros or all ones return `None` unless W has a proper period that exactly reconstructs; e.g., `0000` → `p=2` and `p=1` both reconstruct, but we only return **proper** period `p>1`; algorithm correctly yields `p=2`.

### 2) Global 2D period for a **multi-color** plane bundle

```python
from typing import Dict, List, Tuple, Optional

def period_2d_planes(
    planes: Dict[int, List[int]],  # color -> row masks
    H: int, W: int,
    colors_order: List[int]
) -> Tuple[Optional[int], Optional[int], List[List[int]]]:
    """
    Compute the minimal positive 2D periods (p_r, p_c), each >= 2,
    for the *entire multi-color grid*, or (None, None, []) if no proper period exists.
    Also return residue-class masks (phase fixed at (0,0)) as a list of planes,
    ordered by residue (i,j) in row-major over residues:
      index = i * p_c + j, where i in [0..p_r-1], j in [0..p_c-1].
    Each residue mask is an H-length list[int] (row masks), 1 iff (r % p_r == i and c % p_c == j).
    """
```

**Exact definition (frozen):**

Let the grid be represented by per-color planes `planes[c][r]` with bit j set iff cell (r,j) is color c.

* **Column period p_c:**

  1. For each row `r`, build a **symbol sequence** over columns of length W:
     `sym_r[c] = tuple( (planes[color][r] >> c) & 1 for color in colors_order )`.
     This symbol is a K-bit tuple (K = |colors_order|).
  2. Compute the **minimal 1D period** `t_r` of sequence `sym_r[0..W-1]` using the **prefix function** over equality of K-tuples (generalized KMP; equality only, no hashing).

     * If the row is unconstraining (all K-tuples equal), `t_r` may be any divisor; keep the KMP result (possibly `None`).
  3. Let `S = { t_r | t_r is not None }`. If `S` is empty ⇒ **no constraint** along columns.
     Otherwise set preliminary `p_c = LCM(S)`.
  4. **Validation:** Check that for all rows r and all columns c where c+p_c < W, we have `sym_r[c] == sym_r[c+p_c]`. If this fails, then **no proper column period** exists ⇒ `p_c = None`.

* **Row period p_r:** symmetric to columns:

  1. For each column `c`, build symbol sequence over rows of length H:
     `sym_c[r] = tuple( ((planes[color][r] >> c) & 1) for color in colors_order )`.
  2. Compute minimal 1D period `t_c` (KMP) for each column; let `S' = { t_c | t_c not None }`.
     If `S'` empty ⇒ no row constraint; else `p_r = LCM(S')`.
  3. Validate: for all columns c and all rows r with r+p_r < H, check `sym_c[r] == sym_c[r+p_r]`. If fails ⇒ `p_r = None`.

* **Nontrivial 2D period:** We return `(p_r, p_c)` where each is either `None` or an integer ≥ 2. If both are `None`, residues list is `[]`. If one is `None` and the other not, return the found one (e.g., stripes), and residues will reflect only that dimension (the other dimension’s period is effectively H or W, but we **do not** invent a value; residues still computed using the found period, with phase at (0,0); see residue construction below).

* **Residue masks (phase = (0,0)):**

  * If both `p_r` and `p_c` are present: build `p_r * p_c` residue masks.
  * If only one is present (say `p_c`), set `p_r = 1` for residue construction purposes **internally** (not returned), and build `1 * p_c` masks. Similarly for only `p_r`.
  * If neither is present: residues `[]`.

---

## Underspecified risks (closed here)

* **Multi-color coherence:** We compute periods on **K-tuple symbols** (across all colors) so the period is global; no per-color contradictions.
* **Aggregation across rows/cols:** We use **LCM of per-row (or per-col) minimal periods**, then **validate** globally. This aligns with the math: any multiple of a row’s minimal period is also a period; the LCM is the smallest period satisfying all rows (ditto columns).
* **Phase choice:** Fixed at **(0,0)** (top-left origin), consistent with v1.5.
* **Bounds:** We search via KMP across the full length (no 10-cap); exact and finite (H,W ≤ 30).
* **Trivial vs proper period:** Only return `p ≥ 2` as a “proper” period; otherwise `None`. This prevents declaring “period 1.”
* **Residue construction when only one axis is periodic:** We generate residue masks for the periodic axis only, without inventing a second axis period.

---

## Invariants (must hold)

* **Pure equality logic:** KMP over symbols uses only equality comparisons on K-tuples; no hashing, no floats.
* **Determinism:** Given identical `planes,H,W,colors_order`, results are identical. No randomness, no iteration-order dependence.
* **Validation after LCM:** The chosen `p_r`/`p_c` must pass exact equality checks across the full grid (not just per row/col summaries).
* **Phase fixed:** residues correspond to `(r % p_r, c % p_c)` with origin at (0,0).
* **No minted bits:** This module **never** produces colors—only **masks** and integers.

---

## Failure modes (explicit)

* `ValueError` if plane shapes mismatch `H` or row masks contain bits beyond `[0..W-1]`.
* Otherwise, absence of period is represented by `(None, None, [])`; **not** an exception.

---

## Receipts (first-class; algebraic)

Emit a sealed receipt (via WO-00) summarizing *what was proved*:

* `period.inputs`:

  * `H, W, K = len(colors_order)`
  * `colors_order` (ascending ints)
* `period.candidates`:

  * `row_periods_nontrivial`: list of all `t_r` (ignoring None)
  * `col_periods_nontrivial`: list of all `t_c` (ignoring None)
  * `p_r_lcm_pre`, `p_c_lcm_pre` (before validation, or null)
* `period.validation`:

  * `p_r_valid: true|false`, `p_c_valid: true|false`
  * `p_r` (final or null), `p_c` (final or null)
  * `phase: [0,0]`
* `period.residues`:

  * `count` (= 0 if both None; else `p_r*p_c` or `p_r` or `p_c`)
  * **(Optional but helpful)** first 2–3 residue masks’ **row popcounts** to anchor regressions
* `section_hash` (BLAKE3 over the canonical JSON)

No RNG; the same planes produce the same receipt.

---

## Edge cases (fully specified)

* **All-zero grid:** Both dimensions unconstrained ⇒ `(None, None, [])`.
* **Vertical stripes:** Only `p_c` non-null; `p_r=None`. Residues are `1*p_c` masks (internally treat `p_r=1` for mask construction).
* **Horizontal stripes:** Only `p_r` non-null; symmetric handling.
* **Small sizes:** If `W<2`, then `p_c=None` (cannot have proper period); if `H<2`, then `p_r=None`.
* **Rows/cols with no constraint:** Rows or columns that are constant (all K-tuples equal) yield `t_r=None`/`t_c=None`; they **do not** constrain the LCM.

---

## What’s explicitly **out of scope**

* Picking colors for residues (that’s the lattice emitter’s job).
* Any “phase search”: phase is frozen to (0,0).
* Any non-exact matching (no Hamming thresholds, no FFT).

---

## Developer checklist (Implementer)

* Implement `minimal_period_1d` exactly as KMP prefix-function over {0,1}.
* Implement `period_2d_planes` with **K-tuple symbols** and **LCM-then-validate** logic.
* Validate bit bounds on inputs; raise `ValueError` on violations.
* Produce a receipts dict with the exact keys above via WO-00; no timestamps, no floats.

---

## Reviewer quick-verification on **real ARC tasks** (not unit tests)

* Pick a periodic output (e.g., our tiling task): the returned `(p_r,p_c)` must be non-null and tiling the top-left `p_r×p_c` motif should reconstruct the canvas bit-exact.
* Pick a non-periodic output: at least one of `(p_r,p_c)` must be `None`, and any attempt to tile with a non-null candidate must fail equality under your check.
