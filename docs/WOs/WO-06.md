WO-06 you asked for—grounded in v1.5 + Patch v1.6. It learns **rigid piecewise geometry** and a **color permutation σ** per training pair with **exact equality**, no free translation scan, no heuristics, and with **receipts-first** debugging.

# WO-06 — Witness Matcher (per training)

## Purpose

Given one training pair ((X_i, Y_i)) and its **frames** (Π_in on (X_i), Π_out on (Y_i)), learn a finite set of **rigid pieces**
[
\phi_k: p \mapsto R_k,p + t_k\quad (R_k\in D_4,\ t_k\in\mathbb Z^2)
]
and a **color permutation** (\sigma_i:\ \text{colors}(X_i)\to \text{colors}(Y_i))
such that each accepted piece **exactly** maps one 4-connected component of (X_i) (in Π_in) onto a 4-connected component of (Y_i) (in Π_out), with colors related by (\sigma_i). Overlaps that imply **different colors at any pixel** make the witness **silent**; (\sigma_i) must be a **bijection on the touched input colors**, otherwise **silent**.

No scanning over arbitrary translations: **translations are determined** by matched component **bounding boxes** under a chosen (R\in D_4).

---

## Inputs & Frames (frozen)

* `Xi_raw`, `Yi_raw`: training grids (integers).
* `frames`: object with:

  * `Pi_in = (pid_in, anchor_in)` for (X_i) (WO-3 canonicalizer).
  * `Pi_out = (pid_out, anchor_out)` for (Y_i) (WO-3 canonicalizer).
* Derived **engine views** (do this inside the function, using WO-03/WO-01):

  * `X = Pose(Xi_raw, pid_in)` then **translate by −anchor_in** (zero-fill).
  * `Y = Pose(Yi_raw, pid_out)` then **translate by −anchor_out** (zero-fill).
    These are the working images for matching; colors are **original ARC ints** (no palette).

---

## Interface (pure; deterministic)

```python
from typing import TypedDict, List, Dict, Tuple

class Piece(TypedDict):
    pid: str              # one of ["I","R90","R180","R270","FX","FXR90","FXR180","FXR270"]
    dy: int               # integer translation in engine frame (rows)
    dx: int               # integer translation in engine frame (cols)
    bbox_src: Tuple[int,int,int,int]   # (rmin, cmin, rmax, cmax) in X
    bbox_tgt: Tuple[int,int,int,int]   # (rmin, cmin, rmax, cmax) in Y

class WitnessResult(TypedDict):
    pieces: List[Piece]
    sigma: Dict[int, int]     # color_in -> color_out, bijection on touched colors
    silent: bool              # True iff overlap/conflict prevents using witness
    receipts: Dict            # sealed (WO-00) section

def learn_witness(Xi_raw, Yi_raw, frames) -> WitnessResult:
    ...
```

---

## Exact algorithm (no ambiguity)

### 0) Precompute per-color 4-CC components & shape invariants

* Using **WO-05** on `X` and `Y` **excluding color 0**:

  * For each color (c), get component list with `mask_plane`, `bbox`, and **D4-minimal outline hash** (translation-free, D4-invariant).
* Build **lookup** on `Y`: `by_hash[color_out][outline_hash] -> list of Y-components`, each with its `mask_plane` and `bbox`.

  * Also build `by_hash_anycolor[outline_hash] -> list of (color_out, comp)` to allow **color-agnostic** shape matching before (\sigma) is known.

### 1) Deterministic enumeration of source components

* Iterate **colors** of `X` in ascending order (exclude 0).
* Within each color, iterate components in **row-major order by `bbox_src`** (sort by `rmin`, then `cmin`, then `area` descending to prefer larger anchors).
* For each source component `C_src`:

  * For each **pose** `pid ∈ ["I","R90","R180","R270","FX","FXR90","FXR180","FXR270"]` (frozen order):

    1. **Pose** `C_src`’s mask via `pose_plane` (WO-01) to get `M_src_posed` and its **posed bbox** `(rmin_p, cmin_p, rmax_p, cmax_p)`.
    2. Compute its **outline hash** (pose→re-crop→serialize, WO-05 style). Call it `h_pose`.
    3. From `by_hash_anycolor[h_pose]` (on `Y`), iterate candidate **target components** in **stable order**: sort by `(color_out asc, rmin, cmin, −area)`.

       * For each candidate `C_tgt` with `mask M_tgt` and `bbox_tgt=(rt_min, ct_min, rt_max, ct_max)`:

         * **Compute translation** deterministically (no scan):
           [
           t = (dy,dx) = (rt_min - rmin_p,\ \ ct_min - cmin_p)
           ]
           (the posed source’s top-left aligns to target’s top-left).
         * **Verify exact match:** shift `M_src_posed` by `(dy,dx)` (WO-01 `shift_plane`) and check **rowwise equality** to `M_tgt`. If not equal, **reject** this candidate (`ok=False` in receipts for this trial).
         * If equal:

           * Let (c_{in}) be the source color; (c_{out}) the candidate’s color.
           * **Update σ:**

             * If `sigma` has no entry for `c_in` and `c_out` is not already mapped **from any other `c_in2`**, tentatively set `sigma[c_in]=c_out`.
             * If `sigma[c_in]` exists and `sigma[c_in] != c_out` → **conflict**, **reject** this candidate.
             * If some **other** input color already maps to `c_out` → **injectivity violation**, **reject**.
           * **Provisional piece** ( (pid, dy, dx, bbox_src, bbox_tgt) ) is **accepted**; record and **break** out of candidate loop for this source component (first valid target wins, ensuring determinism).
    4. If no candidate at any pose matched exactly, this source component remains **unmatched** (that’s allowed; witness may cover only part of (Y)).

> **No free translation scan:** translation is derived via **bbox alignment** to candidate targets of the **same D4-invariant shape**; there is no sliding search.

### 2) Overlap and color-consistency check on accepted pieces

* Build **target coverage masks per output color** from accepted pieces:

  * For each piece mapping (c_{in}\to c_{out}), compute its **target mask** `T_piece` (the shifted posed source mask).
  * Maintain:

    * `union_out[c_out] |= T_piece`
    * `overlap_out[c_out] |= (old_union_out[c_out] & T_piece)`
* If **any** `overlap_out[c_out]` has a **1** where *two different pieces* claim **different source colors** that map to **different** `c_out` (by construction they won’t—because `c_out` fixed per piece)—but also check **cross-color**: if a pixel is assigned by two pieces with **different `c_out`**, that is a **hard conflict** → **silent**.

  * Implementation: also maintain `global_union` and `global_owner_color` plane; if `T_piece` sets a bit already owned by a **different `c_out`**, set `witness_overlap_conflict=True`.

### 3) Bijection requirement on touched colors

* Let `TouchedIn = { c_in : c_in had ≥1 accepted piece }`, `TouchedOut = { sigma[c_in] : c_in ∈ TouchedIn }`.
* **Require**: `len(TouchedIn) == len(TouchedOut) == len(sigma)` (i.e., (\sigma) is **bijection on the touched input colors**).

  * If not, set `silent=True`, `pieces=[]`, `sigma={}`.

### 4) Finalize result

* If any of: **overlap conflict**, **σ conflict**, or **bijection fail** → `silent=True`, `pieces=[]`, `sigma={}`.
* Else `silent=False`, return the accepted `pieces` and `sigma`.

---

## Receipts (first-class; algebraic)

Section name: `"witness_train"` (one per training). **Required keys:**

* `inputs`: `{ "H_in":H, "W_in":W, "H_out":H2, "W_out":W2 }`
* `trials`: **array** (in the exact enumeration order) of:

  ```json
  {
    "src_color": 3,
    "src_bbox": [rmin,cmin,rmax,cmax],
    "pose": "R90",
    "t": [dy,dx],
    "outline_hash": "…",
    "tgt_color": 7,
    "tgt_bbox": [rmin,cmin,rmax,cmax],
    "ok": true|false
  }
  ```

  (Record at least every **attempted** candidate that passed the outline-hash filter; if you want to cap volume, you can log only the **first ok** and a count of rejected ones per pose: **add-only**.)
* `pieces`: array of accepted pieces (with fields above).
* `sigma`: `{ "map": { "3":7, ... }, "bijection_ok": true|false, "touched_in": [..], "touched_out": [..] }`
* `overlap`: `{ "conflict": true|false, "conflict_pixels": n, "per_color_overlaps": { "7": m, ... } }`
* `silent`: true|false
* `section_hash`: BLAKE3 over the **stable JSON** (WO-00)

**Determinism proof:** With the same inputs, `trials` order and `pieces` are identical in a double run (no randomness, frozen orders).

---

## Invariants (must hold)

* **No minted bits:** a piece is accepted only if its posed+shifted **exactly equals** a target component mask; we never “paint” extra pixels.
* **No free translation scan:** translation is computed from `bbox` alignment to a **shape-matched** candidate; we never iterate arbitrary `(dy,dx)`.
* **σ conflict ⇒ reject:** if adding a piece would make (\sigma) non-injective or map the same `c_in` to two different `c_out`, **reject** that piece.
* **Overlap conflict ⇒ silent:** if two accepted pieces assign **different target colors** to any pixel, the entire witness becomes **silent**.
* **Partial coverage allowed:** witness may cover only some components; unmatched sources are fine if constraints above hold.

---

## Edge cases (fully specified)

* **All-zero `X` or `Y`:** yields no components ⇒ `pieces=[]`, `sigma={}`, `silent=False` (no conflicts).
* **Multiple Y components sharing the same outline hash:** processed in **deterministic** (color, `rmin`, `cmin`, `−area`) order; first exact match wins for that source component.
* **Multiple source components identical by shape:** handled independently; bijection is on **colors**, not on components.

---

## What’s explicitly out of scope here

* **Conjugation to test frame** (Π_out* ∘ … ∘ Π_in*⁻¹) and **forward admits**—that’s **WO-07**.
* Any **content normalization** or **period** logic.
* Any “best fit”/approximate matching—only exact bitwise equality.

---

## Developer checklist (Implementer)

* Implement D4-invariant **outline hash** comparison and **bbox-based translation**; **no** sliding search.
* Build and use `by_hash_anycolor` index on `Y` components to bound candidate targets.
* Enforce enumeration orders (colors ↑, components by `rmin,cmin,−area`, poses in frozen order, candidate targets by `(color_out, rmin, cmin, −area)`).
* Maintain `sigma` as you go; **reject** any piece that would break injectivity or consistency.
* After accepting all pieces, run the **bijectivity on touched colors** and **overlap conflict** checks; set `silent` accordingly.
* Emit full **receipts** as specified; assert **double-run equality** of `section_hash`.

---

## Reviewer quick-verification (real ARC; 1–2 lines)

* On a simple copy/flip task, `silent=false`, `pieces>0`, `sigma_bijection_ok=true`, and unpacking a piece’s target mask equals the target component exactly.
* On a crafted case where two source colors map to the same target color, witness returns `silent=true` and receipts show `sigma_bijection_ok=false` or `overlap.conflict=true`.

This locks the witness learning down to **pure bit algebra** with a **finite, deterministic** search, and gives you the receipts to diagnose any disagreement at the component/pose/translation level without ever resorting to heuristics.
