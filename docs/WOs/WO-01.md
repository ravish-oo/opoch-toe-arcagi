WO-01 you asked for. It is strictly grounded in the v1.5 addendum + computing spec, uses only core CS primitives, bans heuristics, and makes receipts first-class. No ambiguity left.

# WO-01 — Bit-Planes & Kernel Ops (PACK/UNPACK, SHIFT, POSE, AND/OR/ANDN, PERIOD)

## Purpose

Define the **minimal kernel** of pure operations on packed bit-planes that every higher layer compiles to. This module is math-level: no task logic, no engines, no I/O, no clocks.

---

## Interfaces (pure functions; exact signatures; no optional args)

### 1) Color ordering and plane type

```python
def order_colors(C: set[int]) -> list[int]:
    """Return ascending list of colors; 0 must be present."""
```

```python
# Plane representation:
# A plane is a list[int] of length H; each entry is a nonnegative Python int
# whose W least-significant bits encode row bits (bit j == 1  <=>  cell (r, j) is ON).
# No fixed word size; Python big-int is allowed.
```

### 2) PACK / UNPACK (grid ↔ planes)

```python
def pack_grid_to_planes(G: list[list[int]], H: int, W: int, colors_order: list[int]) -> dict[int, list[int]]:
    """
    For each color c in colors_order, build a plane with row masks.
    Exactly one color bit is set per cell (0..K-1 are mutually exclusive).
    Errors:
      - ValueError if a grid cell color is not in colors_order
      - ValueError if H or W don't match G
    Deterministic, no side-effects.
    """
```

```python
def unpack_planes_to_grid(planes: dict[int, list[int]], H: int, W: int, colors_order: list[int]) -> list[list[int]]:
    """
    Reconstruct the color grid by taking, for each (r,c), the unique color whose bit is 1.
    Errors:
      - ValueError if multiple colors are ON at a cell (non-exclusive planes)
      - ValueError if no color is ON at a cell
      - ValueError if any plane has wrong row count or bits outside 0..W-1
    """
```

### 3) SHIFT (zero-fill; no wrap)

```python
def shift_plane(plane: list[int], dy: int, dx: int, H: int, W: int) -> list[int]:
    """
    Logical translate by (dy, dx). Positive dy moves bits DOWN (to larger r).
    Positive dx moves bits RIGHT (to larger c). Off-canvas bits are dropped.
    """
```

**Exact definition (pull-free, bit-exact):**

* Vertical: if `dy >= 0`: new_rows = [0]*dy + plane[0:H-dy]; else new_rows = plane[-dy:H] + [0]*(-dy).
* Horizontal per row mask `m`:

  * if `dx >= 0`: `(m << dx) & ((1<<W)-1)`
  * else: `(m >> (-dx))`
* Return row list of length H.

### 4) POSE (8 exact D4 transforms; rectangular-aware)

```python
def pose_plane(plane: list[int], pid: str, H: int, W: int) -> tuple[list[int], int, int]:
    """
    Apply one of 8 D4 transforms by coordinate remap; returns (plane', H', W').
    pid ∈ {"I","R90","R180","R270","FX","FXR90","FXR180","FXR270"} with frozen order.
    """
```

**Coordinate system:** rows r∈[0..H-1] top→down, columns c∈[0..W-1] left→right.

**Output shape:**

* If pid ∈ {R90, R270, FXR90, FXR270}: `(H',W')=(W,H)` (swap).
* Else: `(H',W')=(H,W)`.

**Exact “pull” mapping (dest ← src)** — for each destination (r',c') compute source (r,c):

* I:      r=r',                 c=c'
* R90:    r=H-1-c',             c=r'
* R180:   r=H-1-r',             c=W-1-c'
* R270:   r=c',                 c=W-1-r'
* FX:     r=r',                 c=W-1-c'                 (mirror horizontally)
* FXR90:  r=H-1-c',             c=W-1-r'                 (FX ∘ R90)
* FXR180: r=H-1-r',             c=c'                     (FX ∘ R180)
* FXR270: r=c',                 c=r'                     (FX ∘ R270)

If (r,c) is in bounds and source bit is 1, set dest bit 1; else 0. No wrap; no interpolation.

**Inverses (must hold):**

* `pose(pose(plane, pid), inv(pid))` equals `plane` bit-for-bit.
* `inv` mapping is: I↔I, R90↔R270, R180↔R180, FX↔FX, FXR90↔FXR270, FXR180↔FXR180.

### 5) BITWISE

```python
def plane_and(a: list[int], b: list[int], H: int, W: int) -> list[int]
def plane_or(a: list[int], b: list[int], H: int, W: int) -> list[int]
def plane_andn(a: list[int], notmask: list[int], H: int, W: int) -> list[int]
```

Errors:

* ValueError if row counts differ.
* Bits outside `[0..W-1]` are forbidden; must be masked off before combining.

### 6) PERIOD (1D minimal period; pure integer KMP)

```python
def minimal_period_row(mask: int, W: int) -> int|None:
    """
    Return p (2 <= p <= W) if the row's bitstring is an exact repetition
    with minimal period p; else None. Exactly matches integer KMP definition.
    """
```

**Definition:** Convert row to length-W bitstring `s[0..W-1]` with `s[j]=((mask>>j)&1)`.
Let `pi` = prefix function over {0,1}. Let `t = W - pi[W-1]`. If `t < W` and `W % t == 0`, return `t`; else None.

(2D residues and classes belong to the lattice emitter; here we only expose the 1D primitive.)

---

## Invariants (must hold; enforce with asserts)

* **Endianness & bit mapping:** Least significant bit (bit 0) is column 0; per our serializers, bytes are emitted BE with (bit 7 → col 0 ... bit 0 → col 7). Kernel stores Python ints with bit j = column j. Both conventions are fixed and consistent.
* **Row length:** `len(plane) == H` for any plane; every mask has `(mask >> W) == 0`.
* **Exclusivity (only for PACK):** Exactly one color per cell in `pack_grid_to_planes`; `unpack_planes_to_grid` rejects multi-on or all-off cells.
* **POSE correctness:** Applying `pose_plane` then `pose_plane` with inverse pid must reconstruct the original plane exactly (including shapes).
* **Zero-fill:** SHIFT always zero-fills; no wraparound.
* **Determinism:** identical inputs → identical outputs, byte-for-byte.

---

## Failure modes (explicit; no silent fallbacks)

* `ValueError` for shape mismatch, invalid pid, out-of-range bits, or exclusivity violations in unpack.
* No partial results on error; functions are pure.

---

## Receipts (first-class; algebraic debugging)

Every public function should be callable through a small **probe** wrapper in this module that emits a sealed receipt via WO-00:

* `kernel.params_hash` — BLAKE3 of frozen D4 mapping table and inverse table.
* `pack_consistency_hash` — Hash( serialize_grid_be_row_major(G) ) must equal Hash( serialize_planes_be_row_major(pack(G)) ).
* `pose_inverse_ok` — boolean + counts for random-free self-tests over tiny fixtures (checkerboard, single pixel, rectangle) proving `pose ∘ inv == id`.
* `shift_boundary_counts` — number of bits dropped at edges for a known pattern; serves as regression anchor.
* `period_kmp_examples` — for a few canonical rows (solid, stripe(2), stripe(3)), log `W`, `mask`, `p`.

> No RNG: the “examples” are fixed tiny grids under `fixtures/tiny/`.

---

## Edge cases (fully specified)

* **H=0 or W=0:** Allowed. PACK/UNPACK produce/consume empty planes; SHIFT and POSE return empty shapes with no error.
* **Non-square rotation:** POSE swaps H,W for 90/270 (and their FX variants); SHIFT uses the current (H,W).
* **W not multiple of 8:** Internal ints are unbounded; only serializers care about byte packing (WO-00), not this module.
* **All-zero plane:** POSE/SHIFT keep it zero; PERIOD returns `None`.

---

## What is explicitly **out of scope** here

* Any emitter logic (witness, unanimity, lattice-2D, stencils).
* AC-3 or any constraints.
* Majority or heuristics of any kind.

---

## Developer checklist (Implementer)

* Implement exactly the six functions groups above; **no optional parameters**, no globals, no clocks, no randomness.
* Use only Python integers and lists; **no NumPy** (allowed later, not needed here).
* Keep functions pure; do not mutate inputs.
* Validate shapes and bit bounds; raise `ValueError` on violations (never coerce).
* Provide a `kernel_receipts(section_label, fixtures)` helper that logs the receipts items listed above via WO-00.

---

## Reviewer quick-verification on **real ARC tasks** (not unit tests)

* Pick 3 tasks; `pack_grid_to_planes` then `unpack_planes_to_grid` must reconstruct the training grid **exactly**, and the two serializer hashes (grid vs planes) must match.
* Apply `pose_plane(...,"R90")` then inverse on one training input; hash must return to original and dimensions must swap then restore (H×W → W×H → H×W).

---

### Rationale & grounding

* **Color planes & exclusivity** match Spec §1 and Addendum A.
* **SHIFT** zero-fill, no wrap, is the exact integer translation used in witness and stencils.
* **POSE** implements the D4 group from Spec §5 with rectangular awareness and frozen inverse mapping.
* **BITWISE** are the lattice meet/join primitives used by the LFP.
* **PERIOD** uses the textbook KMP prefix-function; 2D usage appears in lattice emitter per v1.5.
* **Receipts** conform to WO-00: big-endian framing is verified by cross-hashing grid vs planes; D4 table is hashed to freeze behavior; no RNG anywhere.

This locks the kernel so every higher module compiles down to these pure, deterministic ops—nothing else.
