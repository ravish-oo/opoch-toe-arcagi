**M2 (Output path) milestone** spelled out for the runner, plus a clean, receipts-driven way to judge which tasks are solved now and which ones are “not yet.”

---

# Milestone M2 — “Output path”

**Prereqs:** WO-04a (working canvas), WO-02 (periods), WO-08 (output transport + unanimity).

## Runner contract (src/arcbit/runner.py) at M2

* **Wire:** `emit_output_transport`, `emit_unity` (unanimity).
* **Disable:** witness, lattice, LFP/AC-3, engine-winner.

```python
def solve(task_json):
    # M0: color_universe, pack/unpack identity, frames
    # M1: choose_working_canvas -> (R_out, C_out)
    # M2: output path only
    A_out_list, S_out_list, transp_recs, transp_section = emit_output_transport(
        Y_train_list, frames_out, R_out, C_order, pi_out_star
    )
    A_uni, S_uni, uni_rec = emit_unity(A_out_list, S_out_list, C_order, R_out, C_out)

    # Minimal selector: unanimity only (no witness, no engine winner)
    # For each pixel: if S_uni[p]==1 pick the unique color in A_uni[*][p]; else pick bottom 0.
    Y_out = select_unanimity_first(A_uni, S_uni, C_order, R_out, C_out)

    # Receipts: +transports +unanimity +selection (precedence ["unanimity","bottom"], counts, repaint_hash)
    return Y_out, receipts_bundle
```

**Notes**

* **No LCM** anywhere: WO-08 already normalizes each (Y_i) to the single ((R_{out},C_{out})) by integer **replicate**/**exact decimate**/**silent**, then transports to (\Pi_{out}^*).
* **Admit-all ⇒ silent** handled in WO-08 by not setting `S_out_i` for silent trainings; unanimity never emits “all colors,” only singletons or silent.

## Receipts (additive; do not change earlier sections)

* `working_canvas` (from M1) unchanged.
* `transports` (WO-08): list of per-training `norm_kind` (replicate/decimate/silent), factors `(s_r,s_c)`, `block_constancy_ok` for decimates, `scope_bits`, `transport_hash`, `n_included`.
* `unanimity`: `included_train_ids`, `unanimous_pixels`, `total_covered_pixels`, `empty_scope_pixels`, `unanimity_hash`, `scope_hash`.
* `selection` (M2):

  * `precedence: ["unanimity","bottom"]`
  * `counts: {"unanimity": N_uni, "bottom": N_bot}`
  * `repaint_hash`, `containment_verified:true`.

## Invariants

* Each included training’s transported layer is **singleton per pixel**; its scope is exactly the pixels it covers.
* **Unanimity** sets `S_uni[p]=1` only if all speaking trainings agree on one color; otherwise `S_uni[p]=0`.
* **Determinism**: frozen family/bounds for normalization; frozen D4 swap set (`R90/R270/FXR90/FXR270` swap, **not** `FXR180`); double-run hashes equal.
* **No new `SIZE_UNDETERMINED`** at M2 (size chosen in M1). A task can still yield `N_uni=0` if no training normalizes or if trainings disagree—that is **Not Yet**, not an error.

---

# What to expect at M2

* **Yes, some tasks will now match ground truth**: precisely those where **the normalized, transported training outputs all agree everywhere** (i.e., full unanimity). Typical examples:

  * Pure constant-color outputs (same color across trainings after transport).
  * Outputs that are simple rescalings/poses of the same pattern (integer replicate/decimate) and agree pixel-wise on the working canvas.

* **Many tasks won’t match yet** (and aren’t supposed to):

  * If **no training can be normalized** to ((R_{out},C_{out})) (e.g., chosen size from H2/H6/H7 doesn’t admit integer replicate/decimate), unanimity is silent → all bottom.
  * If **trainings disagree** at some pixels (after correct transport), `S_uni` is 0 there; selector falls back to bottom; later **EngineWinner (M5)** will decide.
  * If the ground truth uses **colors never present in any training outputs**, unanimity cannot synthesize them; later **Value/Logic** or witness/AC-3 may.

---

# How to triage results after the sweep (taxonomy)

Use existing receipts to tag each task deterministically:

1. **SOLVED_BY_UNANIMITY**

   * `unanimity.unanimous_pixels == R_out * C_out`
   * `selection.counts.unanimity == R_out * C_out`
   * `Y_out == GT`
     → Output path alone solved it.

2. **NOT_YET_NORMALIZATION** (no training can speak)

   * `transports.n_included == 0` **or** `unanimity.total_covered_pixels == 0`
   * `selection.counts.unanimity == 0`, all pixels from bottom
     → Expected at M2; stems from H2/H6/H7 choices or decimation failing exact-block check. Not a bug.

3. **NOT_YET_DISAGREEING_OUTPUTS** (coverage but no unanimity)

   * `total_covered_pixels > 0` **and** `unanimous_pixels < total_covered_pixels`
   * `selection.counts.bottom > 0`
     → Trainings conflict after transport; needs **EngineWinner**/Lattice or LFP (M4/M5).

4. **BUG_TRANSPORT/NORMALIZE** (rare, real issue)

   * `transports.n_included == #trainings`
   * `unanimous_pixels == R_out * C_out` (full unanimity)
   * **but** `Y_out != GT`
     → With full unanimity, selector must pick that color everywhere; mismatch points to a **transport/pose/anchor swap** or a broken selector.
     Cross-check per-train `transport_hash` and pose/anchor pairs; verify `FXR180` not swapping H/W; verify `select_unanimity_first` picks the singleton color.

5. **BUG_RECEIPT/COUNTING** (should be gone after fixes)

   * If `selection.counts.unanimity` claims pixels where `S_uni[p]==0` (or `A_uni` has no bit set) → counting logic bug.
   * Add a safety counter `unanimity_empty_scope_pixels` and require it be **0**.

---

## Reviewer’s 5-step checklist (copy/paste)

1. **Run M2 sweep (output-only):**
   `python -/glue/to/runner.py --with-witness=false --with-unanimity=true`

2. **Check coverage:**
   From `transports`: confirm `n_included`, and from `unanimity`: `total_covered_pixels`, `unanimous_pixels`.

3. **Classify:**

   * If `unanimous_pixels == R_out*C_out` and `Y_out == GT` → **SOLVED_BY_UNANIMITY**.
   * If `total_covered_pixels == 0` → **NOT_YET_NORMALIZATION**.
   * Else if `unanimous_pixels < total_covered_pixels` → **NOT_YET_DISAGREEING_OUTPUTS**.

4. **Bug checks (only if needed):**

   * Full unanimity but `Y_out ≠ GT` → **BUG_TRANSPORT/NORMALIZE** (inspect pose/anchor/factors and selector).
   * `unanimity_empty_scope_pixels > 0` or counts don’t match `S_uni` → **BUG_RECEIPT/COUNTING**.

5. **Log counts** for dashboards: `n_included`, `unanimous_pixels`, `total_covered_pixels`, `selection.counts`.

---

This keeps M2 strictly within the **output consensus** lane. You’ll see some tasks solved outright (consensus), many marked **Not Yet** (need M4/M5), and only a small, well-isolated set of genuine bugs (if any), all backed by receipts you can grep.
