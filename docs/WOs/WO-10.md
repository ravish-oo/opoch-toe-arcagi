WO-10 you asked for—frozen to our v1.6 spec, using only core CS (sets/bitsets, a fixed 4-neighbor graph, and textbook AC-3). No heuristics, no catalogs. It is receipts-first and deterministic.

# WO-10 — Forbids + AC-3 (4-neighbor)

## Purpose

1. **Learn a forbid matrix (M(c,d))** on the **working canvas** that encodes **adjacent color pairs that are disallowed** (directed if we can prove direction, symmetric otherwise).
2. **Run AC-3** over the current per-pixel domains (D) with **frozen** queue order to prune impossible colors before the fixed-point stage (WO-11).

> **No LCM**. All coordinates are on ((R_{out}, C_{out})).

---

## Inputs (frozen)

* For learning forbids: the **normalized & transported training outputs** on the working canvas, i.e. the per-training integer grids (Y_i) that WO-08 reconstructs (or equivalently their planes (A^{out}_i) + scopes). Only **included** (non-silent) trainings are used.
* For AC-3: a **domain tensor** (D) for the test canvas, represented as per-pixel color sets (bit-planes over `colors_order`).

**Color order:** ascending integers; includes 0.

---

## Interfaces (pure; receipts-first)

```python
from typing import Dict, List, Tuple, Optional, TypedDict, Set

# Forbid matrix: M[c][d] == 1 means (c at p, d at q) is FORBIDDEN for an edge (p,q).
# We expose a dense bit-matrix or sparse dict-of-sets; receipts carry a hash.

def learn_forbids(
    Y_train_list: List[List[List[int]]],  # per-training integer grids on (R_out, C_out)
    included_train_ids: List[int],
    colors_order: List[int]
) -> Tuple[List[Tuple[int,int,int,int]], Dict[int, Set[int]], Dict]:
    """
    Returns:
      E_graph : list of directed 4-neighbor edges (p->q) as tuples (pr, pc, qr, qc) in row-major order.
      M       : forbid matrix as dict c -> set of d forbidden after c (directed).
      receipt : {"forbid_symmetric": bool, "matrix_hash": str, "edges_count": int, ...}
    """
```

```python
class AC3Stats(TypedDict):
    queue_init_len: int
    arcs_processed: int
    prunes: int                   # total removed (p,c) pairs
    passes: int                   # number of while-loop passes (>=1)
    empties: int                  # number of pixels that became empty (signals UNSAT upstream)
    section_hash: str

def ac3_prune(
    D: Dict[Tuple[int,int], int],         # per-pixel domain bitmask over colors_order
    E_graph: List[Tuple[int,int,int,int]],
    M: Dict[int, Set[int]],               # forbid matrix
    colors_order: List[int]
) -> Tuple[bool, AC3Stats]:
    """
    AC-3 with frozen queue:
      - Init queue with ALL arcs (p->q) in row-major order.
      - For arc (p->q), remove c ∈ D[p] if ∀ d ∈ D[q], M[c][d] == 1 (no supporting d).
      - On prune at p: enqueue all arcs (r->p) for r neighbors in row-major order.

    Returns:
      changed : bool (True if any prune happened)
      stats   : AC3Stats
    """
```

---

## E_graph (frozen 4-neighbor directed edges)

* Nodes are pixels ((r,c)).
* **Undirected** adjacency is ({(r,c)\leftrightarrow(r\pm1,c),(r,c)\leftrightarrow(r,c\pm1)}) when in-bounds.
* We represent it as a **directed** set of arcs ( (p \to q) ) in **row-major**:

  * Iterate (p=(r,c)) row-major; for each neighbor (q) in the fixed order **UP, LEFT, RIGHT, DOWN** (or **UP, RIGHT, DOWN, LEFT**—pick one, freeze it), append ( (p\to q) ) if in-bounds.
* Receipts must include `edges_count = len(E_graph)`.

---

## Learning forbids (M) (no heuristics)

We learn only what the trainings **prove**. Unseen or ambiguous pairs are **permissive** (0). We avoid “absence of evidence” forbids.

**Allowed in v1.6: one universal family + optional directed entries (when provable)**

1. **Universal “adjacent cells must differ”** (symmetric (M(c,c)=1)) **iff** BOTH:

   * Across **all included trainings**, **no** adjacent equal-color pair is ever observed (no ((c,c)) on any 4-neighbor edge), **and**
   * For **every color (c)** that appears **on at least one edge** (i.e., has an adjacent neighbor somewhere), we observed at least one adjacency involving (c) (so the rule is not vacuous for (c)).

   Then set (M[c][c] = 1) for those (c)’s; leave (M[c][c]=0) for colors that never appeared on any edge (no evidence).

   > This rule is **provably safe**: if any training had a ((c,c)) adjacency, we wouldn’t add the forbid; we don’t infer from mere absence unless we saw (c) involved in adjacencies.

2. **Directed forbids** (M[c][d]=1) (rare) only when **provable**:
   For a fixed orientation (say (p\to q) as RIGHT neighbor), if across **all trainings** and across **all edges with that orientation**, whenever (p) has color (c), (q) **never** has color (d), **and** we observed that orientation with (p) taking (c) at least once (non-vacuous), then set (M[c][d]=1) for that orientation **and only for that orientation**.

   * We then **aggregate** across orientations conservatively: unless **all four orientations** prove the same (M[c][d]=1), we treat it as **directionless** evidence and **do not** add a directed forbid. (We can extend to per-orientation forbids later if/when we carry per-edge matrices.)

**Default:** (M) is all zeros if nothing is provable. That is perfectly fine—AC-3 then prunes nothing (receipts will show zeros).

**Receipts for learning:**

* `forbid_symmetric: true|false` (true if only (M[c][c]=1) kind of forbids present; false if any off-diagonal forbids existed).
* `matrix_hash`: BLAKE3 over a canonical byte layout of M (e.g., row-major over `colors_order`, each row a bitset over columns).
* `evidence`: (optional, add-only) total observed edge counts, per-color edge presence counts.

---

## AC-3 (frozen queue order; fail-closed stats)

Let (D[p]\subseteq\mathcal C) be a per-pixel bitset of admissible colors (from emitters up to this point). We run AC-3:

* **Initialize queue** with all arcs ( (p\to q) \in E_graph ) in **row-major** order of (p), then the fixed neighbor order for (q).
* While queue not empty:

  * Pop ((p\to q)) **FIFO**.
  * For each color (c \in D[p]), check **support** in (D[q]):

    * If **for all** (d \in D[q]), (M[c][d]==1) (i.e., ((c,d)) is forbidden), then **remove** (c) from (D[p]).
    * Count this as one **prune**. If (D[p]) becomes empty, increment `empties` (WO-11 will detect UNSAT).
  * If **any prune** happened at (p), then **enqueue** all arcs ((r\to p)) for neighbors (r) of (p), in the same fixed row-major order.
* Collect stats:

  * `queue_init_len`, `arcs_processed`, `prunes`, `passes` (we can count outer while-iterations or simply set `passes=1` and rely on `arcs_processed`; either way it must be deterministic), `empties`.

**Return:** `(changed, stats)` where `changed` is `True` iff `prunes > 0`.

**Receipts:** return `stats` sealed (BLAKE3 over a stable JSON with those fields).

---

## Canonical byte layouts for hashing

* **Matrix hash**: For each `c` in `colors_order`, serialize a row bitmask over `colors_order` where bit `d` is 1 iff (M[c][d]=1). Concatenate rows in order; hash the bytes.
* **Graph edges count** suffices; we don’t hash E_graph (its definition is frozen by spec).

---

## Invariants

* **4-neighbor only**; no diagonals, no wrap.
* **Directed arcs**, frozen queue order, FIFO.
* **Permissive by default**: all unseen pairs allowed (matrix zeros).
* **No heuristics**: we set forbids only when **explicitly provable** from observed adjacencies.
* **Determinism**: given the same inputs and color order, `matrix_hash`, `edges_count`, and AC-3 stats must be identical across runs.

---

## Edge cases

* If **no trainings included** → (M) stays all zeros; AC-3 just returns `(False, stats with prunes=0)`.
* If (D) is already singletons everywhere → AC-3 runs, `prunes=0`, no changes.
* If any pixel domain becomes **empty** → `empties > 0`; WO-11 will escalate to UNSAT.

---

## What’s explicitly out of scope

* Any “learned” per-orientation forbids beyond the universal differ rule (we keep directed forbids conservative).
* High-order or non-local forbids (they belong to later logic/CSP WOs).
* Using forbids to **introduce** values (AC-3 only prunes).

---

## Developer checklist

* Build `E_graph` once per canvas; verify `edges_count = (H*(W-1) + (H-1)*W) * 2` (directed) with borders handled.
* Implement adjacency scan over all included (Y_i); record **edge occurrences** and equality occurrences; set (M[c][c]=1) only if the universal differ proof passes (no equal adjacencies and non-vacuous for c). Leave all others at 0.
* Implement AC-3 exactly as above (frozen queue/FIFO, on prune enqueue predecessors only).
* Emit **learning** receipt and **AC-3 stats** receipt; check double-run stability.

---

## Reviewer quick-verification (real ARC; 1–2 lines)

* On a toy **“adjacent must differ”** dataset (no equal 4-neighbors across trainings), verify `forbid_symmetric=true`, `matrix_hash≠0`, and AC-3 prunes equal-color neighbors from a multi-valued (D).
* Determinism: run twice—`edges_count`, `matrix_hash`, and AC-3 stats (`prunes`, `arcs_processed`) must be identical.
